// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgensm

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/travelgateX/presenters-benchmark/pkg/access"
	"github.com/travelgateX/presenters-benchmark/pkg/common"
	"github.com/travelgateX/presenters-benchmark/pkg/domainHotelCommon"
	"github.com/travelgateX/presenters-benchmark/pkg/search"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	HotelOptionSearch() HotelOptionSearchResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddOn struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	AddOns struct {
		Distribute   func(childComplexity int) int
		Distribution func(childComplexity int) int
	}

	AuditData struct {
		ProcessTime  func(childComplexity int) int
		TimeStamp    func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	Bed struct {
		Count       func(childComplexity int) int
		Description func(childComplexity int) int
		Shared      func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	CancelPenalty struct {
		Currency    func(childComplexity int) int
		HoursBefore func(childComplexity int) int
		Type        func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	CancelPolicy struct {
		CancelPenalties func(childComplexity int) int
		Refundable      func(childComplexity int) int
	}

	CriteriaSearch struct {
		CheckIn     func(childComplexity int) int
		CheckOut    func(childComplexity int) int
		Currency    func(childComplexity int) int
		Hotels      func(childComplexity int) int
		Language    func(childComplexity int) int
		Market      func(childComplexity int) int
		Nationality func(childComplexity int) int
		Occupancies func(childComplexity int) int
	}

	Error struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Exchange struct {
		Currency func(childComplexity int) int
		Rate     func(childComplexity int) int
	}

	HotelOptionSearch struct {
		Access            func(childComplexity int) int
		AddOns            func(childComplexity int) int
		BoardCode         func(childComplexity int) int
		BoardCodeOriginal func(childComplexity int) int
		CancelPolicy      func(childComplexity int) int
		HotelCode         func(childComplexity int) int
		HotelCodeSupplier func(childComplexity int) int
		HotelName         func(childComplexity int) int
		Market            func(childComplexity int) int
		Occupancies       func(childComplexity int) int
		OptionID          func(childComplexity int) int
		PaymentType       func(childComplexity int) int
		Price             func(childComplexity int) int
		RateRules         func(childComplexity int) int
		Remarks           func(childComplexity int) int
		Rooms             func(childComplexity int) int
		Status            func(childComplexity int) int
		Supplements       func(childComplexity int) int
		Supplier          func(childComplexity int) int
		Surcharges        func(childComplexity int) int
		Token             func(childComplexity int) int
	}

	HotelSearch struct {
		AuditData       func(childComplexity int) int
		Context         func(childComplexity int) int
		Errors          func(childComplexity int) int
		Options         func(childComplexity int) int
		RequestCriteria func(childComplexity int) int
		Stats           func(childComplexity int, token string) int
		Warnings        func(childComplexity int) int
	}

	HotelXQuery struct {
		Search              func(childComplexity int) int
		SearchStatusService func(childComplexity int) int
	}

	Markup struct {
		Binding  func(childComplexity int) int
		Channel  func(childComplexity int) int
		Currency func(childComplexity int) int
		Exchange func(childComplexity int) int
		Gross    func(childComplexity int) int
		Net      func(childComplexity int) int
		Rules    func(childComplexity int) int
	}

	Occupancy struct {
		Id    func(childComplexity int) int
		Paxes func(childComplexity int) int
	}

	Pax struct {
		Age func(childComplexity int) int
	}

	Price struct {
		Binding  func(childComplexity int) int
		Currency func(childComplexity int) int
		Exchange func(childComplexity int) int
		Gross    func(childComplexity int) int
		Markups  func(childComplexity int) int
		Net      func(childComplexity int) int
	}

	PriceBreakdown struct {
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Price         func(childComplexity int) int
	}

	Promotion struct {
		Code          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	Query struct {
		HotelX func(childComplexity int) int
	}

	RatePlan struct {
		Code          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	Resort struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	Room struct {
		Beds           func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		OccupancyRefID func(childComplexity int) int
		Promotions     func(childComplexity int) int
		RatePlans      func(childComplexity int) int
		Refundable     func(childComplexity int) int
		RoomPrice      func(childComplexity int) int
		Units          func(childComplexity int) int
	}

	RoomCriteria struct {
		Paxes func(childComplexity int) int
	}

	RoomPrice struct {
		Breakdown func(childComplexity int) int
		Price     func(childComplexity int) int
	}

	Rule struct {
		Id    func(childComplexity int) int
		Name  func(childComplexity int) int
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Search struct {
		Hotel func(childComplexity int, token *string, criteria *HotelCriteriaSearchInput, settings *domainHotelCommon.Settings, filter *search.Filter) int
	}

	ServiceStatus struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Stat struct {
		Duration func(childComplexity int) int
		End      func(childComplexity int) int
		Start    func(childComplexity int) int
	}

	StatAccess struct {
		Cities              func(childComplexity int) int
		Hotels              func(childComplexity int) int
		Name                func(childComplexity int) int
		Plugins             func(childComplexity int) int
		RequestAccess       func(childComplexity int) int
		ResponseAccess      func(childComplexity int) int
		StaticConfiguration func(childComplexity int) int
		Total               func(childComplexity int) int
		Transactions        func(childComplexity int) int
		Zones               func(childComplexity int) int
	}

	StatPlugin struct {
		Name  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	StatTransaction struct {
		BuildRequest        func(childComplexity int) int
		ParseResponse       func(childComplexity int) int
		Reference           func(childComplexity int) int
		Total               func(childComplexity int) int
		WorkerCommunication func(childComplexity int) int
	}

	StatsRequest struct {
		Accesses       func(childComplexity int) int
		Cities         func(childComplexity int) int
		Configuration  func(childComplexity int) int
		DockerID       func(childComplexity int) int
		Hotels         func(childComplexity int) int
		Process        func(childComplexity int) int
		Request        func(childComplexity int) int
		RequestPlugin  func(childComplexity int) int
		Response       func(childComplexity int) int
		ResponsePlugin func(childComplexity int) int
		Total          func(childComplexity int) int
		Validation     func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	Supplement struct {
		ChargeType     func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		DurationType   func(childComplexity int) int
		EffectiveDate  func(childComplexity int) int
		ExpireDate     func(childComplexity int) int
		Mandatory      func(childComplexity int) int
		Name           func(childComplexity int) int
		Price          func(childComplexity int) int
		Quantity       func(childComplexity int) int
		Resort         func(childComplexity int) int
		SupplementType func(childComplexity int) int
		Unit           func(childComplexity int) int
	}

	Surcharge struct {
		ChargeType  func(childComplexity int) int
		Description func(childComplexity int) int
		Mandatory   func(childComplexity int) int
		Price       func(childComplexity int) int
	}

	Transactions struct {
		Request   func(childComplexity int) int
		Response  func(childComplexity int) int
		TimeStamp func(childComplexity int) int
	}

	Warning struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}
}

type HotelOptionSearchResolver interface {
	RateRules(ctx context.Context, obj *domainHotelCommon.Option) ([]RateRulesType, error)

	AddOns(ctx context.Context, obj *domainHotelCommon.Option) (*AddOns, error)
}
type QueryResolver interface {
	HotelX(ctx context.Context) (*HotelXQuery, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddOn.Key":
		if e.complexity.AddOn.Key == nil {
			break
		}

		return e.complexity.AddOn.Key(childComplexity), true

	case "AddOn.Value":
		if e.complexity.AddOn.Value == nil {
			break
		}

		return e.complexity.AddOn.Value(childComplexity), true

	case "AddOns.Distribute":
		if e.complexity.AddOns.Distribute == nil {
			break
		}

		return e.complexity.AddOns.Distribute(childComplexity), true

	case "AddOns.Distribution":
		if e.complexity.AddOns.Distribution == nil {
			break
		}

		return e.complexity.AddOns.Distribution(childComplexity), true

	case "AuditData.ProcessTime":
		if e.complexity.AuditData.ProcessTime == nil {
			break
		}

		return e.complexity.AuditData.ProcessTime(childComplexity), true

	case "AuditData.TimeStamp":
		if e.complexity.AuditData.TimeStamp == nil {
			break
		}

		return e.complexity.AuditData.TimeStamp(childComplexity), true

	case "AuditData.Transactions":
		if e.complexity.AuditData.Transactions == nil {
			break
		}

		return e.complexity.AuditData.Transactions(childComplexity), true

	case "Bed.Count":
		if e.complexity.Bed.Count == nil {
			break
		}

		return e.complexity.Bed.Count(childComplexity), true

	case "Bed.Description":
		if e.complexity.Bed.Description == nil {
			break
		}

		return e.complexity.Bed.Description(childComplexity), true

	case "Bed.Shared":
		if e.complexity.Bed.Shared == nil {
			break
		}

		return e.complexity.Bed.Shared(childComplexity), true

	case "Bed.Type":
		if e.complexity.Bed.Type == nil {
			break
		}

		return e.complexity.Bed.Type(childComplexity), true

	case "CancelPenalty.Currency":
		if e.complexity.CancelPenalty.Currency == nil {
			break
		}

		return e.complexity.CancelPenalty.Currency(childComplexity), true

	case "CancelPenalty.HoursBefore":
		if e.complexity.CancelPenalty.HoursBefore == nil {
			break
		}

		return e.complexity.CancelPenalty.HoursBefore(childComplexity), true

	case "CancelPenalty.Type":
		if e.complexity.CancelPenalty.Type == nil {
			break
		}

		return e.complexity.CancelPenalty.Type(childComplexity), true

	case "CancelPenalty.Value":
		if e.complexity.CancelPenalty.Value == nil {
			break
		}

		return e.complexity.CancelPenalty.Value(childComplexity), true

	case "CancelPolicy.CancelPenalties":
		if e.complexity.CancelPolicy.CancelPenalties == nil {
			break
		}

		return e.complexity.CancelPolicy.CancelPenalties(childComplexity), true

	case "CancelPolicy.Refundable":
		if e.complexity.CancelPolicy.Refundable == nil {
			break
		}

		return e.complexity.CancelPolicy.Refundable(childComplexity), true

	case "CriteriaSearch.CheckIn":
		if e.complexity.CriteriaSearch.CheckIn == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckIn(childComplexity), true

	case "CriteriaSearch.CheckOut":
		if e.complexity.CriteriaSearch.CheckOut == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckOut(childComplexity), true

	case "CriteriaSearch.Currency":
		if e.complexity.CriteriaSearch.Currency == nil {
			break
		}

		return e.complexity.CriteriaSearch.Currency(childComplexity), true

	case "CriteriaSearch.Hotels":
		if e.complexity.CriteriaSearch.Hotels == nil {
			break
		}

		return e.complexity.CriteriaSearch.Hotels(childComplexity), true

	case "CriteriaSearch.Language":
		if e.complexity.CriteriaSearch.Language == nil {
			break
		}

		return e.complexity.CriteriaSearch.Language(childComplexity), true

	case "CriteriaSearch.Market":
		if e.complexity.CriteriaSearch.Market == nil {
			break
		}

		return e.complexity.CriteriaSearch.Market(childComplexity), true

	case "CriteriaSearch.Nationality":
		if e.complexity.CriteriaSearch.Nationality == nil {
			break
		}

		return e.complexity.CriteriaSearch.Nationality(childComplexity), true

	case "CriteriaSearch.Occupancies":
		if e.complexity.CriteriaSearch.Occupancies == nil {
			break
		}

		return e.complexity.CriteriaSearch.Occupancies(childComplexity), true

	case "Error.Code":
		if e.complexity.Error.Code == nil {
			break
		}

		return e.complexity.Error.Code(childComplexity), true

	case "Error.Description":
		if e.complexity.Error.Description == nil {
			break
		}

		return e.complexity.Error.Description(childComplexity), true

	case "Error.Type":
		if e.complexity.Error.Type == nil {
			break
		}

		return e.complexity.Error.Type(childComplexity), true

	case "Exchange.Currency":
		if e.complexity.Exchange.Currency == nil {
			break
		}

		return e.complexity.Exchange.Currency(childComplexity), true

	case "Exchange.Rate":
		if e.complexity.Exchange.Rate == nil {
			break
		}

		return e.complexity.Exchange.Rate(childComplexity), true

	case "HotelOptionSearch.Access":
		if e.complexity.HotelOptionSearch.Access == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Access(childComplexity), true

	case "HotelOptionSearch.AddOns":
		if e.complexity.HotelOptionSearch.AddOns == nil {
			break
		}

		return e.complexity.HotelOptionSearch.AddOns(childComplexity), true

	case "HotelOptionSearch.BoardCode":
		if e.complexity.HotelOptionSearch.BoardCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCode(childComplexity), true

	case "HotelOptionSearch.BoardCodeOriginal":
		if e.complexity.HotelOptionSearch.BoardCodeOriginal == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCodeOriginal(childComplexity), true

	case "HotelOptionSearch.CancelPolicy":
		if e.complexity.HotelOptionSearch.CancelPolicy == nil {
			break
		}

		return e.complexity.HotelOptionSearch.CancelPolicy(childComplexity), true

	case "HotelOptionSearch.HotelCode":
		if e.complexity.HotelOptionSearch.HotelCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCode(childComplexity), true

	case "HotelOptionSearch.HotelCodeSupplier":
		if e.complexity.HotelOptionSearch.HotelCodeSupplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCodeSupplier(childComplexity), true

	case "HotelOptionSearch.HotelName":
		if e.complexity.HotelOptionSearch.HotelName == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelName(childComplexity), true

	case "HotelOptionSearch.Market":
		if e.complexity.HotelOptionSearch.Market == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Market(childComplexity), true

	case "HotelOptionSearch.Occupancies":
		if e.complexity.HotelOptionSearch.Occupancies == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Occupancies(childComplexity), true

	case "HotelOptionSearch.OptionID":
		if e.complexity.HotelOptionSearch.OptionID == nil {
			break
		}

		return e.complexity.HotelOptionSearch.OptionID(childComplexity), true

	case "HotelOptionSearch.PaymentType":
		if e.complexity.HotelOptionSearch.PaymentType == nil {
			break
		}

		return e.complexity.HotelOptionSearch.PaymentType(childComplexity), true

	case "HotelOptionSearch.Price":
		if e.complexity.HotelOptionSearch.Price == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Price(childComplexity), true

	case "HotelOptionSearch.RateRules":
		if e.complexity.HotelOptionSearch.RateRules == nil {
			break
		}

		return e.complexity.HotelOptionSearch.RateRules(childComplexity), true

	case "HotelOptionSearch.Remarks":
		if e.complexity.HotelOptionSearch.Remarks == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Remarks(childComplexity), true

	case "HotelOptionSearch.Rooms":
		if e.complexity.HotelOptionSearch.Rooms == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Rooms(childComplexity), true

	case "HotelOptionSearch.Status":
		if e.complexity.HotelOptionSearch.Status == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Status(childComplexity), true

	case "HotelOptionSearch.Supplements":
		if e.complexity.HotelOptionSearch.Supplements == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Supplements(childComplexity), true

	case "HotelOptionSearch.Supplier":
		if e.complexity.HotelOptionSearch.Supplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Supplier(childComplexity), true

	case "HotelOptionSearch.Surcharges":
		if e.complexity.HotelOptionSearch.Surcharges == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Surcharges(childComplexity), true

	case "HotelOptionSearch.Token":
		if e.complexity.HotelOptionSearch.Token == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Token(childComplexity), true

	case "HotelSearch.AuditData":
		if e.complexity.HotelSearch.AuditData == nil {
			break
		}

		return e.complexity.HotelSearch.AuditData(childComplexity), true

	case "HotelSearch.Context":
		if e.complexity.HotelSearch.Context == nil {
			break
		}

		return e.complexity.HotelSearch.Context(childComplexity), true

	case "HotelSearch.Errors":
		if e.complexity.HotelSearch.Errors == nil {
			break
		}

		return e.complexity.HotelSearch.Errors(childComplexity), true

	case "HotelSearch.Options":
		if e.complexity.HotelSearch.Options == nil {
			break
		}

		return e.complexity.HotelSearch.Options(childComplexity), true

	case "HotelSearch.RequestCriteria":
		if e.complexity.HotelSearch.RequestCriteria == nil {
			break
		}

		return e.complexity.HotelSearch.RequestCriteria(childComplexity), true

	case "HotelSearch.Stats":
		if e.complexity.HotelSearch.Stats == nil {
			break
		}

		args, err := ec.field_HotelSearch_stats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.HotelSearch.Stats(childComplexity, args["token"].(string)), true

	case "HotelSearch.Warnings":
		if e.complexity.HotelSearch.Warnings == nil {
			break
		}

		return e.complexity.HotelSearch.Warnings(childComplexity), true

	case "HotelXQuery.Search":
		if e.complexity.HotelXQuery.Search == nil {
			break
		}

		return e.complexity.HotelXQuery.Search(childComplexity), true

	case "HotelXQuery.SearchStatusService":
		if e.complexity.HotelXQuery.SearchStatusService == nil {
			break
		}

		return e.complexity.HotelXQuery.SearchStatusService(childComplexity), true

	case "Markup.Binding":
		if e.complexity.Markup.Binding == nil {
			break
		}

		return e.complexity.Markup.Binding(childComplexity), true

	case "Markup.Channel":
		if e.complexity.Markup.Channel == nil {
			break
		}

		return e.complexity.Markup.Channel(childComplexity), true

	case "Markup.Currency":
		if e.complexity.Markup.Currency == nil {
			break
		}

		return e.complexity.Markup.Currency(childComplexity), true

	case "Markup.Exchange":
		if e.complexity.Markup.Exchange == nil {
			break
		}

		return e.complexity.Markup.Exchange(childComplexity), true

	case "Markup.Gross":
		if e.complexity.Markup.Gross == nil {
			break
		}

		return e.complexity.Markup.Gross(childComplexity), true

	case "Markup.Net":
		if e.complexity.Markup.Net == nil {
			break
		}

		return e.complexity.Markup.Net(childComplexity), true

	case "Markup.Rules":
		if e.complexity.Markup.Rules == nil {
			break
		}

		return e.complexity.Markup.Rules(childComplexity), true

	case "Occupancy.Id":
		if e.complexity.Occupancy.Id == nil {
			break
		}

		return e.complexity.Occupancy.Id(childComplexity), true

	case "Occupancy.Paxes":
		if e.complexity.Occupancy.Paxes == nil {
			break
		}

		return e.complexity.Occupancy.Paxes(childComplexity), true

	case "Pax.Age":
		if e.complexity.Pax.Age == nil {
			break
		}

		return e.complexity.Pax.Age(childComplexity), true

	case "Price.Binding":
		if e.complexity.Price.Binding == nil {
			break
		}

		return e.complexity.Price.Binding(childComplexity), true

	case "Price.Currency":
		if e.complexity.Price.Currency == nil {
			break
		}

		return e.complexity.Price.Currency(childComplexity), true

	case "Price.Exchange":
		if e.complexity.Price.Exchange == nil {
			break
		}

		return e.complexity.Price.Exchange(childComplexity), true

	case "Price.Gross":
		if e.complexity.Price.Gross == nil {
			break
		}

		return e.complexity.Price.Gross(childComplexity), true

	case "Price.Markups":
		if e.complexity.Price.Markups == nil {
			break
		}

		return e.complexity.Price.Markups(childComplexity), true

	case "Price.Net":
		if e.complexity.Price.Net == nil {
			break
		}

		return e.complexity.Price.Net(childComplexity), true

	case "PriceBreakdown.EffectiveDate":
		if e.complexity.PriceBreakdown.EffectiveDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.EffectiveDate(childComplexity), true

	case "PriceBreakdown.ExpireDate":
		if e.complexity.PriceBreakdown.ExpireDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.ExpireDate(childComplexity), true

	case "PriceBreakdown.Price":
		if e.complexity.PriceBreakdown.Price == nil {
			break
		}

		return e.complexity.PriceBreakdown.Price(childComplexity), true

	case "Promotion.Code":
		if e.complexity.Promotion.Code == nil {
			break
		}

		return e.complexity.Promotion.Code(childComplexity), true

	case "Promotion.EffectiveDate":
		if e.complexity.Promotion.EffectiveDate == nil {
			break
		}

		return e.complexity.Promotion.EffectiveDate(childComplexity), true

	case "Promotion.ExpireDate":
		if e.complexity.Promotion.ExpireDate == nil {
			break
		}

		return e.complexity.Promotion.ExpireDate(childComplexity), true

	case "Promotion.Name":
		if e.complexity.Promotion.Name == nil {
			break
		}

		return e.complexity.Promotion.Name(childComplexity), true

	case "Query.HotelX":
		if e.complexity.Query.HotelX == nil {
			break
		}

		return e.complexity.Query.HotelX(childComplexity), true

	case "RatePlan.Code":
		if e.complexity.RatePlan.Code == nil {
			break
		}

		return e.complexity.RatePlan.Code(childComplexity), true

	case "RatePlan.EffectiveDate":
		if e.complexity.RatePlan.EffectiveDate == nil {
			break
		}

		return e.complexity.RatePlan.EffectiveDate(childComplexity), true

	case "RatePlan.ExpireDate":
		if e.complexity.RatePlan.ExpireDate == nil {
			break
		}

		return e.complexity.RatePlan.ExpireDate(childComplexity), true

	case "RatePlan.Name":
		if e.complexity.RatePlan.Name == nil {
			break
		}

		return e.complexity.RatePlan.Name(childComplexity), true

	case "Resort.Code":
		if e.complexity.Resort.Code == nil {
			break
		}

		return e.complexity.Resort.Code(childComplexity), true

	case "Resort.Description":
		if e.complexity.Resort.Description == nil {
			break
		}

		return e.complexity.Resort.Description(childComplexity), true

	case "Resort.Name":
		if e.complexity.Resort.Name == nil {
			break
		}

		return e.complexity.Resort.Name(childComplexity), true

	case "Room.Beds":
		if e.complexity.Room.Beds == nil {
			break
		}

		return e.complexity.Room.Beds(childComplexity), true

	case "Room.Code":
		if e.complexity.Room.Code == nil {
			break
		}

		return e.complexity.Room.Code(childComplexity), true

	case "Room.Description":
		if e.complexity.Room.Description == nil {
			break
		}

		return e.complexity.Room.Description(childComplexity), true

	case "Room.OccupancyRefID":
		if e.complexity.Room.OccupancyRefID == nil {
			break
		}

		return e.complexity.Room.OccupancyRefID(childComplexity), true

	case "Room.Promotions":
		if e.complexity.Room.Promotions == nil {
			break
		}

		return e.complexity.Room.Promotions(childComplexity), true

	case "Room.RatePlans":
		if e.complexity.Room.RatePlans == nil {
			break
		}

		return e.complexity.Room.RatePlans(childComplexity), true

	case "Room.Refundable":
		if e.complexity.Room.Refundable == nil {
			break
		}

		return e.complexity.Room.Refundable(childComplexity), true

	case "Room.RoomPrice":
		if e.complexity.Room.RoomPrice == nil {
			break
		}

		return e.complexity.Room.RoomPrice(childComplexity), true

	case "Room.Units":
		if e.complexity.Room.Units == nil {
			break
		}

		return e.complexity.Room.Units(childComplexity), true

	case "RoomCriteria.Paxes":
		if e.complexity.RoomCriteria.Paxes == nil {
			break
		}

		return e.complexity.RoomCriteria.Paxes(childComplexity), true

	case "RoomPrice.Breakdown":
		if e.complexity.RoomPrice.Breakdown == nil {
			break
		}

		return e.complexity.RoomPrice.Breakdown(childComplexity), true

	case "RoomPrice.Price":
		if e.complexity.RoomPrice.Price == nil {
			break
		}

		return e.complexity.RoomPrice.Price(childComplexity), true

	case "Rule.Id":
		if e.complexity.Rule.Id == nil {
			break
		}

		return e.complexity.Rule.Id(childComplexity), true

	case "Rule.Name":
		if e.complexity.Rule.Name == nil {
			break
		}

		return e.complexity.Rule.Name(childComplexity), true

	case "Rule.Type":
		if e.complexity.Rule.Type == nil {
			break
		}

		return e.complexity.Rule.Type(childComplexity), true

	case "Rule.Value":
		if e.complexity.Rule.Value == nil {
			break
		}

		return e.complexity.Rule.Value(childComplexity), true

	case "Search.Hotel":
		if e.complexity.Search.Hotel == nil {
			break
		}

		args, err := ec.field_Search_hotel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Search.Hotel(childComplexity, args["token"].(*string), args["criteria"].(*HotelCriteriaSearchInput), args["settings"].(*domainHotelCommon.Settings), args["filter"].(*search.Filter)), true

	case "ServiceStatus.Code":
		if e.complexity.ServiceStatus.Code == nil {
			break
		}

		return e.complexity.ServiceStatus.Code(childComplexity), true

	case "ServiceStatus.Description":
		if e.complexity.ServiceStatus.Description == nil {
			break
		}

		return e.complexity.ServiceStatus.Description(childComplexity), true

	case "ServiceStatus.Type":
		if e.complexity.ServiceStatus.Type == nil {
			break
		}

		return e.complexity.ServiceStatus.Type(childComplexity), true

	case "Stat.Duration":
		if e.complexity.Stat.Duration == nil {
			break
		}

		return e.complexity.Stat.Duration(childComplexity), true

	case "Stat.End":
		if e.complexity.Stat.End == nil {
			break
		}

		return e.complexity.Stat.End(childComplexity), true

	case "Stat.Start":
		if e.complexity.Stat.Start == nil {
			break
		}

		return e.complexity.Stat.Start(childComplexity), true

	case "StatAccess.Cities":
		if e.complexity.StatAccess.Cities == nil {
			break
		}

		return e.complexity.StatAccess.Cities(childComplexity), true

	case "StatAccess.Hotels":
		if e.complexity.StatAccess.Hotels == nil {
			break
		}

		return e.complexity.StatAccess.Hotels(childComplexity), true

	case "StatAccess.Name":
		if e.complexity.StatAccess.Name == nil {
			break
		}

		return e.complexity.StatAccess.Name(childComplexity), true

	case "StatAccess.Plugins":
		if e.complexity.StatAccess.Plugins == nil {
			break
		}

		return e.complexity.StatAccess.Plugins(childComplexity), true

	case "StatAccess.RequestAccess":
		if e.complexity.StatAccess.RequestAccess == nil {
			break
		}

		return e.complexity.StatAccess.RequestAccess(childComplexity), true

	case "StatAccess.ResponseAccess":
		if e.complexity.StatAccess.ResponseAccess == nil {
			break
		}

		return e.complexity.StatAccess.ResponseAccess(childComplexity), true

	case "StatAccess.StaticConfiguration":
		if e.complexity.StatAccess.StaticConfiguration == nil {
			break
		}

		return e.complexity.StatAccess.StaticConfiguration(childComplexity), true

	case "StatAccess.Total":
		if e.complexity.StatAccess.Total == nil {
			break
		}

		return e.complexity.StatAccess.Total(childComplexity), true

	case "StatAccess.Transactions":
		if e.complexity.StatAccess.Transactions == nil {
			break
		}

		return e.complexity.StatAccess.Transactions(childComplexity), true

	case "StatAccess.Zones":
		if e.complexity.StatAccess.Zones == nil {
			break
		}

		return e.complexity.StatAccess.Zones(childComplexity), true

	case "StatPlugin.Name":
		if e.complexity.StatPlugin.Name == nil {
			break
		}

		return e.complexity.StatPlugin.Name(childComplexity), true

	case "StatPlugin.Total":
		if e.complexity.StatPlugin.Total == nil {
			break
		}

		return e.complexity.StatPlugin.Total(childComplexity), true

	case "StatTransaction.BuildRequest":
		if e.complexity.StatTransaction.BuildRequest == nil {
			break
		}

		return e.complexity.StatTransaction.BuildRequest(childComplexity), true

	case "StatTransaction.ParseResponse":
		if e.complexity.StatTransaction.ParseResponse == nil {
			break
		}

		return e.complexity.StatTransaction.ParseResponse(childComplexity), true

	case "StatTransaction.Reference":
		if e.complexity.StatTransaction.Reference == nil {
			break
		}

		return e.complexity.StatTransaction.Reference(childComplexity), true

	case "StatTransaction.Total":
		if e.complexity.StatTransaction.Total == nil {
			break
		}

		return e.complexity.StatTransaction.Total(childComplexity), true

	case "StatTransaction.WorkerCommunication":
		if e.complexity.StatTransaction.WorkerCommunication == nil {
			break
		}

		return e.complexity.StatTransaction.WorkerCommunication(childComplexity), true

	case "StatsRequest.Accesses":
		if e.complexity.StatsRequest.Accesses == nil {
			break
		}

		return e.complexity.StatsRequest.Accesses(childComplexity), true

	case "StatsRequest.Cities":
		if e.complexity.StatsRequest.Cities == nil {
			break
		}

		return e.complexity.StatsRequest.Cities(childComplexity), true

	case "StatsRequest.Configuration":
		if e.complexity.StatsRequest.Configuration == nil {
			break
		}

		return e.complexity.StatsRequest.Configuration(childComplexity), true

	case "StatsRequest.DockerID":
		if e.complexity.StatsRequest.DockerID == nil {
			break
		}

		return e.complexity.StatsRequest.DockerID(childComplexity), true

	case "StatsRequest.Hotels":
		if e.complexity.StatsRequest.Hotels == nil {
			break
		}

		return e.complexity.StatsRequest.Hotels(childComplexity), true

	case "StatsRequest.Process":
		if e.complexity.StatsRequest.Process == nil {
			break
		}

		return e.complexity.StatsRequest.Process(childComplexity), true

	case "StatsRequest.Request":
		if e.complexity.StatsRequest.Request == nil {
			break
		}

		return e.complexity.StatsRequest.Request(childComplexity), true

	case "StatsRequest.RequestPlugin":
		if e.complexity.StatsRequest.RequestPlugin == nil {
			break
		}

		return e.complexity.StatsRequest.RequestPlugin(childComplexity), true

	case "StatsRequest.Response":
		if e.complexity.StatsRequest.Response == nil {
			break
		}

		return e.complexity.StatsRequest.Response(childComplexity), true

	case "StatsRequest.ResponsePlugin":
		if e.complexity.StatsRequest.ResponsePlugin == nil {
			break
		}

		return e.complexity.StatsRequest.ResponsePlugin(childComplexity), true

	case "StatsRequest.Total":
		if e.complexity.StatsRequest.Total == nil {
			break
		}

		return e.complexity.StatsRequest.Total(childComplexity), true

	case "StatsRequest.Validation":
		if e.complexity.StatsRequest.Validation == nil {
			break
		}

		return e.complexity.StatsRequest.Validation(childComplexity), true

	case "StatsRequest.Zones":
		if e.complexity.StatsRequest.Zones == nil {
			break
		}

		return e.complexity.StatsRequest.Zones(childComplexity), true

	case "Supplement.ChargeType":
		if e.complexity.Supplement.ChargeType == nil {
			break
		}

		return e.complexity.Supplement.ChargeType(childComplexity), true

	case "Supplement.Code":
		if e.complexity.Supplement.Code == nil {
			break
		}

		return e.complexity.Supplement.Code(childComplexity), true

	case "Supplement.Description":
		if e.complexity.Supplement.Description == nil {
			break
		}

		return e.complexity.Supplement.Description(childComplexity), true

	case "Supplement.DurationType":
		if e.complexity.Supplement.DurationType == nil {
			break
		}

		return e.complexity.Supplement.DurationType(childComplexity), true

	case "Supplement.EffectiveDate":
		if e.complexity.Supplement.EffectiveDate == nil {
			break
		}

		return e.complexity.Supplement.EffectiveDate(childComplexity), true

	case "Supplement.ExpireDate":
		if e.complexity.Supplement.ExpireDate == nil {
			break
		}

		return e.complexity.Supplement.ExpireDate(childComplexity), true

	case "Supplement.Mandatory":
		if e.complexity.Supplement.Mandatory == nil {
			break
		}

		return e.complexity.Supplement.Mandatory(childComplexity), true

	case "Supplement.Name":
		if e.complexity.Supplement.Name == nil {
			break
		}

		return e.complexity.Supplement.Name(childComplexity), true

	case "Supplement.Price":
		if e.complexity.Supplement.Price == nil {
			break
		}

		return e.complexity.Supplement.Price(childComplexity), true

	case "Supplement.Quantity":
		if e.complexity.Supplement.Quantity == nil {
			break
		}

		return e.complexity.Supplement.Quantity(childComplexity), true

	case "Supplement.Resort":
		if e.complexity.Supplement.Resort == nil {
			break
		}

		return e.complexity.Supplement.Resort(childComplexity), true

	case "Supplement.SupplementType":
		if e.complexity.Supplement.SupplementType == nil {
			break
		}

		return e.complexity.Supplement.SupplementType(childComplexity), true

	case "Supplement.Unit":
		if e.complexity.Supplement.Unit == nil {
			break
		}

		return e.complexity.Supplement.Unit(childComplexity), true

	case "Surcharge.ChargeType":
		if e.complexity.Surcharge.ChargeType == nil {
			break
		}

		return e.complexity.Surcharge.ChargeType(childComplexity), true

	case "Surcharge.Description":
		if e.complexity.Surcharge.Description == nil {
			break
		}

		return e.complexity.Surcharge.Description(childComplexity), true

	case "Surcharge.Mandatory":
		if e.complexity.Surcharge.Mandatory == nil {
			break
		}

		return e.complexity.Surcharge.Mandatory(childComplexity), true

	case "Surcharge.Price":
		if e.complexity.Surcharge.Price == nil {
			break
		}

		return e.complexity.Surcharge.Price(childComplexity), true

	case "Transactions.Request":
		if e.complexity.Transactions.Request == nil {
			break
		}

		return e.complexity.Transactions.Request(childComplexity), true

	case "Transactions.Response":
		if e.complexity.Transactions.Response == nil {
			break
		}

		return e.complexity.Transactions.Response(childComplexity), true

	case "Transactions.TimeStamp":
		if e.complexity.Transactions.TimeStamp == nil {
			break
		}

		return e.complexity.Transactions.TimeStamp(childComplexity), true

	case "Warning.Code":
		if e.complexity.Warning.Code == nil {
			break
		}

		return e.complexity.Warning.Code(childComplexity), true

	case "Warning.Description":
		if e.complexity.Warning.Description == nil {
			break
		}

		return e.complexity.Warning.Description(childComplexity), true

	case "Warning.Type":
		if e.complexity.Warning.Type == nil {
			break
		}

		return e.complexity.Warning.Type(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `schema {
  query: Query
}

type Query{
  hotelX: HotelXQuery
}

type HotelXQuery{
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  search: HotelSearch

  # Returns status of the search service.
  searchStatusService: ServiceStatus!
}

# Available options for a given date and itinerary. It does not filter different classes, times or
# fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
# forward.
type Search {
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  hotel(token: String, criteria: HotelCriteriaSearchInput, settings: HotelSettingsInput, filter: FilterInput): HotelSearch @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

# Business rules type
enum BusinessRulesType {
  # The cheapest options is returned without exceeding the optionsQuota limit.
  CHEAPER_AMOUNT
  
  # Groups the option by room type without exceeding the optionsQuota limit.
  ROOM_TYPE
}

# Options type
enum CancelPenaltyType {
  # Indicates the number of nights to be penalized.
  NIGHTS
  
  # Indicates the percentage to pay based on the option price.
  PERCENT
  
  # Indicates the exact amount payable.
  IMPORT
}

# Charge Type
enum ChargeType {
  # The charge is included.
  INCLUDE
  
  # The charge is excluded.
  EXCLUDE
}

# Duration Type
enum DurationType {
  # Date range is set.
  RANGE
  
  # Not restricted by date.
  OPEN
}

# Indicates what type of value is the markup, by percentage or is an import.
enum MarkupRuleType {
  # Indicates the percentage applied by a rule.
  PERCENT
  
  # Indicates the exact amount applied by a rule.
  IMPORT
}

# Plugin Step Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginStepType {
  # Plugins executed after Buyer requests message to HotelX
  REQUEST
  
  # Plugins executed before sending request to Supplier using Access and after Accesses have been calculated
  REQUEST_ACCESS
  
  # Plugins executed after Supplier responds message. For every option returned
  RESPONSE_OPTION
  
  # Plugins executed after all Access options has been responded
  RESPONSE_ACCESS
  
  # Plugins executed before HotelX responds message to to Buyer
  RESPONSE
}

# Plugin Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginType {
  # PRE_STEP is the first plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  PRE_STEP
  
  # HOTEL_MAP allows to match Seller and Buyer hotel codes based on contexts
  HOTEL_MAP
  
  # BOARD_MAP allows to match Seller and Buyer board codes based on contexts
  BOARD_MAP
  
  # ROOM_MAP allows to match Seller and Buyer room codes based on contexts
  ROOM_MAP
  
  # CURRENCY_CONVERSION allows to match Seller and Buyer hotel codes based on contexts
  CURRENCY_CONVERSION
  
  # MARKUP allows to apply markup over price
  MARKUP
  
  # AGGREGATION allows to aggregate multiple supplier options
  AGGREGATION
  
  # POST_STEP is the last plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  POST_STEP
}

# Price Type
enum PriceType {
  # Price without deductions.
  GROSS
  
  # Price after deducting all discounts and rebates.
  NET
  
  # Final quantity. Sum of multiple quantities.
  AMOUNT
}

# Service Type
enum ServiceType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort. Gross.
  SKI_PASS
}

# Indicartes options status
enum StatusType {
  # The status of the avail is available
  OK
  
  # The status of the avail is On request
  RQ
}

# Supplement Type
enum SupplementType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort.
  SKI_PASS
  
  # Lessons of any type that the costumer can take.
  LESSONS
  
  # Supplement of a determined meal plan.
  MEALS
  
  # Extra equipment for a specific purpose.
  EQUIPMENT
  
  # Admission to some service.
  TICKET
  
  # Transfers used by the costumer.
  TRANSFERS
  
  # Gala: A festive occasion, celebration or special entertainment.
  GALA
  
  # Activities that the costumer can do.
  ACTIVITY
}

# Unit Time Type
enum UnitTimeType {
  # Day
  DAY
  
  # Hour
  HOUR
}

# Options payment type
enum PaymentType {
  # The payment is managed by the supplier.
  MERCHANT
  
  # The payment is made straight to the actual payee, without sending it through an intermediary or a third party.
  DIRECT
  
  # The payment is managed by the supplier. The payment is effectuated at the time of booking.
  CARD_BOOKING
  
  # The payment is managed by the supplier. The payment is effectuated at check in in the hotel.
  CARD_CHECK_IN
}

# Rate Rules
enum RateRulesType {
  # The product can't be sold separately from another product attached to it, such as a flight.
  PACKAGE
  
  # Options that can only be sold to people who are 55 and older.
  OLDER55
  
  # Options that can only be sold to people who are 60 and older.
  OLDER60
  
  # Options that can only be sold to people who are 65 and older.
  OLDER65
  
  # The rate CanaryResident is applicable to Canary Islands residents only.
  CANARY_RESIDENT
  
  # The rate BalearicResident is applicable to Balearic Islands residents only.
  BALEARIC_RESIDENT
  
  # The rate largeFamily is applied to large families and is determined by each supplier
  LARGE_FAMILY
  
  # The rate honeymoon is applied to those who just got married and is determined by each supplier.
  HONEYMOON
  
  # The rate publicServant is applicable to public servants only.
  PUBLIC_SERVANT
  
  # The rate unemployed is applied to those without work.
  UNEMPLOYED

  #The rate normal refers to options without RateRule
  NORMAL

  #The rate non refundable is applied to non refundable options
  NON_REFUNDABLE
}

# Include *OR* exclude accesses in this specific search query. If not specified, default accesses will be used.
# Only one list (includes or excludes) *MUST* be used.
input AccessFilterInput {
  # These Access IDs will overwrite the default configuration. Only the IDs on this list will be used in the search query.
  includes: [ID!]
  
  # These Access IDs will overwrite the default configuration. The IDs on this list will be excluded from the search query.
  excludes: [ID!]
}

# List of business rules to use as filter on the options.
input BusinessRulesInput {
  # Options quota per search. Maximum numbers of options to be returned by the search query.
  optionsQuota: Int
  
  # Different business rules to filter the returned options.
  businessRulesType: BusinessRulesType
}

# The information and credentials required to access the supplierâ€™s system.
input ConfigurationInput {
  # User name for the connection.
  username: String
  
  # Password for the connection
  password: String
  
  # URL or endpoint for the connection.
  urls:           UrlsInput!
  
  # List of parameters with additional required information.
  parameters: [ParameterInput!]
  
  # Source Markets allowed for the Access
  markets: [String!]
  
  # RateRules allowed for the access.
  rateRules: [RateRulesType!]
}

input HotelXFilterSearchInput{
  # Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
  # You must choose one of them, include or exclude, or the other alternative isn't specified anything.
  # If input both, you will receive a validation error that indicates this error.

  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput

  # Only is possible to specify one of this filters, it allows to filter which plugins have to be executed or excluded
  plugin: HotelXPluginFilterInput
}
# Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
# You must choose one of them, include or exclude, or the other alternative isn't specified anything.
# If input both, you will receive a validation error that indicates this error.
#@deprecated(reason: "deprecated from 2018-08-20. Please, use filterSearch")
input FilterInput {
  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput
}

# Search criteria contains destination, travel dates and the number of pax in each room.
# You must preload the other fields in our system by complete the fields absents.
input HotelCriteriaSearchInput {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Hotel Codes.
  hotels: [String!]

  # Destination codes.
  destinations: [String!]
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomInput!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String
}

# Settings that you can edit for this avail. Values are loaded by default in our Back Office.
input HotelSettingsInput {
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  #Indicates if you want use context, or not, by default is true.
  #@deprecated(reason: "deprecated from 2017-12-12. Redundant.")
  useContext: Boolean
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  #@deprecated(reason: "deprecated from 2018-03-19. Redundant.")
  connectUser: String
  
  # Client name, this field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  client: ID
  
  # Group whose resources want to be used
  group: ID
  
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Returns all the transactions exchanged with the supplier.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput
  
  # Array of suppliers. Each one contains its own code, settings and accesses.
  suppliers: [HotelXSupplierInput!]
  
  # Array of plugins to execute.
  plugins: [PluginStepInput!]

  # This flag allows only the accesses checked as test. By default is production.
  testMode: Boolean

  # Used to identify the origin of the request, this is only used in plugins. 
  clientTokens: [String!] 
}

# AccessInput overwrites an existent access in our Back Office or creates a new
# one to be used in this search query only. An access object contains its own code, configuration and settings.
input HotelXAccessInput {
  # The accessID used to identify the existing access in our Back Office in order to
  # overwrite it. Acts as an identifier in this search. It can either exist or not.
  accessId: ID!
  
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
  
  # You can configure an special settings for any access. This level overwrites the search and supplier settings levels.
  settings: SettingsBaseInput
}

# Supplier object. Contains its own settings, code and access.
input HotelXSupplierInput {
  # You can configure an special settings for any supplier. This level overwrites the avail settings level but not the
  # access settings level.
  settings: SettingsBaseInput
  
  # Code that represents a supplier in our system.
  # This information is mandatory.
  code: String!
  
  # Array of accesses that can overwrite an existing access information or include a new access for this avail.
  accesses: [HotelXAccessInput!]
}

# Pax object that contains the pax age.
input PaxInput {
  # Pax age.
  age: Int!
}

# If requested, only options with the specified rateRules will be returned
input RateRulesFilterInput {
  # if includes not nil: only options without rate rules and options with rate rules found in includes will be returned
  includes: [RateRulesType!]
  
  # if excludes not nil: only options without rate rules and options with rate rules that haven't been sent in excludes will be returned
  excludes: [RateRulesType!]
}

# Occupancy for a room. It contains a list of pax ages.
input RoomInput {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [PaxInput!]!
}

# Plugin to execute.
input PluginsInput {
  # type of the plugins to execute
  type: PluginType!
  
  # name of plugin to execute
  name: String!
  
  # Plugin's parameters
  parameters: [ParameterInput!]
}

# Plugin to execute.
input PluginStepInput {
  # Indicates where the plugin will be executed.
  step: PluginStepType!
  
  # Indicates the plugin that will be executed.
  pluginsType: [PluginsInput!]
}

# Contains the time out and business rules of a supplier or an access.
input SettingsBaseInput {
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Specifies if transactions exchanged with the supplier have to be logged or not.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput

  # The currency
  currency: Currency
}

input HotelXPluginFilterInput{
  # Plugins to include (only these plugins will be executed)
  includes: [HotelXFilterPluginTypeInput!]
  # Plugins to exclude
  excludes: [HotelXFilterPluginTypeInput!]
}
input HotelXFilterPluginTypeInput{
  # The Step of the plugin to filter
  step: PluginStepType!
  # The Type of the plugin to filter
  type: String!
  # The Name of the plugin to filter
  name: String!
}
# Parameters Input.
input ParameterInput {  
  # Contains the keyword/Id to identify a parameter.
  # This information is mandatory.
  key: String!
  # Contains the parameter values.
  # This information is mandatory.
  value: String!
}

# URLs Input
input UrlsInput {
  # Specific URL for Availability method.
  search:         URI
  # Specific URL for Reservation method.
  quote:          URI
  # Specific URL for Valuation method.
  book:           URI
  # Supplier URL used for multiple methods.
  generic:        URI
}

interface BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Indicates the id to be used on Quote as key
  id: String!
}

interface Priceable {
  # Specifies the currency.
  currency: Currency!
  
  # Is binding.
  binding: Boolean!
  
  # Specifies the import net.
  net: Float!
  
  # Specifies the import gross.
  gross: Float
  
  # Specifies the exchange.
  exchange: Exchange!
}

interface Response {
  # Application stats
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplierâ€™s original format.
  auditData: AuditData
  
  # Errors that lead the service to stop
  errors: [Error!]
  
  # Potentially harmful situations or errors that do not stop the service
  warnings: [Warning!]
}

# Additional information about the option
type AddOns {
  # Extra information from the distribution layer
  distribute: JSON @deprecated(reason: "deprecated from 2018-05-21. You can find it in distribution AddOn")
  
  # Extra information from the distribution layer
  distribution: [AddOn!]
}

# Additional information about the option
type AddOn {
  # Contains keyword/ID to identify the AddOn.
  key: String!
  
  # Contains AddOn values.
  value: JSON!
}

# Data sent and received in the supplierâ€™s native format.
type AuditData {
  # List of transactions data
  transactions:    [Transactions!]!
  
  # TimeStamp
  timeStamp:       DateTime!
  
  # Process time in milliseconds (ms)
  processTime:     Float!
}

# Contains information about a bed.
type Bed {
  # Specifies the bed type
  type: String
  
  # Description about the bed
  description: String
  
  # Indicates number of beds in a room
  count: Int
  
  # Specifies if the bed is shared or not
  shared: Boolean
}

# Contains information for cancellation penalities..
type CancelPenalty {
  # Cancellation fees applicable X number of hours before the check-in date
  hoursBefore: Int!
  
  # Type of penalty; this can be Nights, Percent or Import
  penaltyType: CancelPenaltyType!
  
  # Currency used in the cancellation policy
  currency: Currency!
  
  # Value of the cancellation policy
  value: Float!
}

# Information about a policy cancellation.
type CancelPolicy {
  # Indicates if the option is refundable or non-refundable
  refundable: Boolean!
  
  # List of cancellation penalties
  cancelPenalties: [CancelPenalty!]
}

# Search criteria contains destination, travel dates and the number of pax in each room.
type CriteriaSearch {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Contains the list of hotels's ID
  hotels: [String!]!
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomCriteria!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String!
}

# Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
type Exchange {
  # Provide information about the currency of origin
  currency: Currency!
  
  # Provides information about the rate applied over results
  rate: Float!
}

# An option includes hotel information, meal plan, total price, conditions and room description
type HotelOptionSearch implements BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Market of this option.
  market: String!
  
  # Code of the hotel in the context selected.
  hotelCode: String!
  
  # Supplier's hotel code.
  hotelCodeSupplier: String!
  
  # Name of the hotel.
  hotelName: String
  
  # Code of the board in the context selected.
  boardCode: String!
  
  # Supplier's board code.
  boardCodeSupplier: String!
  
  # Indicates the payment type of the option returned. Possible options: Merchant, Direct, Card Booking, Card check in and Mixed.
  paymentType: PaymentType!
  
  # The possible values in status in response are Available (OK) or On Request (RQ).
  status: StatusType!
  
  # List of occupancies for the request
  occupancies: [Occupancy!]!
  
  # List of rooms of the option returned.
  rooms: [Room!]!
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price!
  
  # List of supplements of the option returned.
  supplements: [Supplement]
  
  # List of surcharges of the option returned.
  surcharges: [Surcharge!]!
  
  # Specifies rate rules of the option returned.
  rateRules: [RateRulesType!]
  
  # Specifies cancel policies of the option returned.
  cancelPolicy: CancelPolicy
  
  # Additional information about the option.
  remarks: String
  
  # Additional information about the option
  addOns: AddOns
  
  # Token for Deep Link
  token: String!
  
  # Indicates the quote key
  id: String!
}

# Results from Avail Hotel; contains all the available options for a given date and itinerary
type HotelSearch implements Response {
  # Indicates the context of the response.
  context: String
  
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Request Criteria
  requestCriteria: CriteriaSearch
  
  # List of options returned according to the request.
  options: [HotelOptionSearch]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors that won't force the service to abort
  warnings: [Warning!]
}

# Informs markup applied over supplier price.
type Markup implements Priceable {
  #channel of markup application.
  channel: String
  
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier plus the markup.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer plus the markup.
  gross: Float
  
  # Informs about the currency of origin, and the rate applied over result.
  # This information is mandatory.
  exchange: Exchange!
  
  # Breakdown of the applied rules for a markup
  rules: [Rule!]!
}

# Information about occupancy.
type Occupancy {
  # Unique ID room in this option.
  id: Int!
  
  # List of pax of this occupancy.
  paxes: [Pax!]!
}

# Specifies the age pax. The range of what is considered an adult, infant or baby is particular to each supplier.
type Pax {
  # Specifies the age pax.
  age: Int!
}

# Price indicates the value of the room/option.
# Supplements and/or surcharges can be included into the price, and will be verified with nodes Supplements/Surcharges.
type Price implements Priceable {
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer.
  gross: Float
  
  # Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
  # This information is mandatory.
  exchange: Exchange!
  
  # Informs markup applied over supplier price.
  markups: [Markup!]
}

# Contains internal information.
type StatsRequest {
  # Total transaction time
  total:          Stat!
  
  # Request validation time
  validation:     Stat!
  
  # Process time. Contains communication time, parse time and plugin time.
  process:        Stat!
  
  # Build access time
  configuration:	Stat!
  
  # Request time
  request:				Stat!
  
  # Response time
  response:       Stat!
  
  # Plugin execution time
  requestPlugin:  StatPlugin
  
  # Plugin execution time
  responsePlugin: StatPlugin
  
  # Number of hotels
  hotels:         Int!
  
  # Number of zones
  zones:          Int!
  
  # Number of cities
  cities:         Int!
  
  # Docker Id
  dockerID:       String!
  
  # Detail access time
  Accesses:       [StatAccess!]!
}

# Information about daily price.
type PriceBreakdown {
  # Start date in which the price becomes effective.
  effectiveDate: Date!
  
  # Expire date of price.
  expireDate: Date!
  
  # Specifies the daily price.
  price: Price!
}

# Information about room promotions(offers).
type Promotion {
  # Specifies the promotion code.
  code: String!
  
  # Specifies the promotion name.
  name: String
  
  # Promotion effective date.
  effectiveDate: Date
  
  # Promotion expire date.
  expireDate: Date
}

# Information about the rate of the option returned.
type RatePlan {
  # Specifies the rate code.
  code: String!
  
  # Specifies the rate name.
  name: String
  
  # Start date in which the rate becomes effective.
  effectiveDate: Date
  
  # Expire date of the rate.
  expireDate: Date
}

# Contains information about the Resort.
type Resort {
  # Specifies the resort code.
  code: String!
  
  # Specifies the resort name.
  name: String
  
  # Specifies the resort description.
  description: String
}

# Contains the room information of the option returned.
type Room {
  # ID reference to the occupancy
  occupancyRefId: Int!
  
  # Indicates the room code
  code: String!
  
  # Description about the room
  description: String
  
  # Identifies if the room is refundable or not.
  refundable: Boolean
  
  # Number of rooms available with the same type.
  units: Int
  
  # Specifies the room price.
  roomPrice: RoomPrice!
  
  # List of beds.
  beds: [Bed!]
  
  # Daily break downs rate plan.
  ratePlans: [RatePlan!]
  
  # Daily break downs promotions.
  promotions: [Promotion!]
}

# Occupancy for a room. It contains a list of pax ages.
type RoomCriteria {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [Pax!]!
}

# Specifies the room price.
type RoomPrice {
  # Total price for all days.
  price: Price!
  
  # Daily break downs price.
  breakdown: [PriceBreakdown!]
}

type Rule {
  # rule identifier
  id: String!
  
  # rule name
  name: String
  
  # type of the value
  type: MarkupRuleType!
  
  # value applied by this rule
  value: Float!
}

# Indicates the status of the service
type ServiceStatus{
  # Status code
  code: String
  
  # Status type
  type: String
  
  # Status description
  description : String
}

type Stat {
  # Start UTC
  start:      DateTime!
  
  # End UTC
  end:        DateTime!
  
  # Difference between start and end in miliseconds
  duration:   Float
}

type StatAccess {
  # Access name
  name:                   String!
  
  # Total access time
  total:                  Stat!
  
  # Static configuration time
  staticConfiguration:    Stat
  
  # Number of hotels
  hotels:                 Int!
  
  # Number of zones
  zones:                  Int!
  
  # Number of cities
  cities:                 Int!
  
  # Access request time
  requestAccess:          StatPlugin
  
  # Access response time
  responseAccess:         StatPlugin
  
  # Detail transaction time
  transactions:           [StatTransaction!]!
  
  # Plugin execution time
  plugins:                [StatPlugin!]
}

type StatTransaction {
  # Extra information about transaction.
  reference:              String!
  
  # Total transaction time
  total:                  Stat!
  
  # Build request time
  buildRequest:           Stat!
  
  # Worker connection time
  workerCommunication:    Stat!
  
  # Parse response time
  parseResponse:          Stat!
}

type StatPlugin{
  # Plugin name
  name:     String!
  
  # total plugin time
  total:    Stat!
}

# Supplement that it can be or its already added to the option returned. Contains all the information about the supplement.
type Supplement {
  # Specifies the supplement code.
  code: String!
  
  # Specifies the supplement name.
  name: String
  
  # Specifies the supplement description.
  description: String
  
  # Indicates the supplement type. Possible types: Fee, Ski_pass, Lessons, Meals, Equipment, Ticket, Transfers, Gla, Activity or Null.
  supplementType: SupplementType!
  
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this supplement is mandatory and included in the option's price
  # when exclude: this supplement is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the supplement is mandatory or not. If mandatory, this supplement will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Specifies the duration type. Possible duration types: Range (specified dates) or Open. This field is mandatory for PDI.
  durationType: DurationType
  
  # Indicates the quantity of field in the element "unit".
  quantity: Int
  
  # Indicates the unit type. Possible unit types: Day or Hour.
  unit: UnitTimeType
  
  # Indicates the effective date of the supplement.
  effectiveDate: Date
  
  # Indicates the expire date of the supplement.
  expireDate: Date
  
  # Contains information about the resort
  resort: Resort
  
  # Indicates the supplement price.
  price: Price
}

# Surcharge that it can be or it is already added to the option returned. Contains all the information about the surcharge.
type Surcharge {
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this surcharge is mandatory and included in the option's price
  # when exclude: this surcharge is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the surcharge is mandatory or not. If mandatory, this surcharge will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Indicates the surcharge price.
  price: Price!
  
  # Specifies the surcharge description.
  description: String
}

# Supplier transaction
type Transactions {
  # Transaction Request.
  request:        String!
  
  # Transaction Response.
  response:       String!
  
  # Time when the request has been processed.
  timeStamp:      DateTime!
}

# Application errors
type Error {
  # Error code
  code: String!

  # Error type
  type: String!

  # Error description
  description : String!
}

# Application warnings
type Warning {
  # Warning code
  code: String!

  # Warning type
  type: String!

  # Warning description
  description : String!
}

# The Country type represents Country values. A good example might be a Passenger Nationality.
# In queries or mutations, Country fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "ES".
scalar Country

# The Currenty type represents Currency values. A good example might be a Rate Price Currency.
# In queries or mutations, Currency fields have to be specified in ISO 4217 format with enclosing double quotes "EUR".
scalar Currency

# The Date type represents Date values. A good example might be a Hotel CheckIn Date.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22".
scalar Date

# The DateTime type represents DateTime values. A good example might be a transaction TimeSpan.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22T13:57:31.123Z".
scalar DateTime

# The JSON type makes sure that it is actually valid JSON and returns the value as a parsed JSON object/array instead of a string.
# In queries or mutations, JSON fields have to be specified with enclosing double quotes. Special characters have to be escaped: "{\"int\": 1, \"string\": \"value\"}".
scalar JSON

# The Language type represents Language values. A good example might be a Hotel Description Language.
# In queries or mutations, Language fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "es".
scalar Language

# The URI type represents a URI values. A good example mith be an Hotel Image URL.
# In queries or mutations, URI fields have to be specified in RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string format with enclosing double quotes: "http:\\www.travelgatex.com".
scalar URI

`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_HotelSearch_stats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["token"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Search_hotel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["token"]; ok {
		arg0, err = ec.unmarshalOString2áš–string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	var arg1 *HotelCriteriaSearchInput
	if tmp, ok := rawArgs["criteria"]; ok {
		arg1, err = ec.unmarshalOHotelCriteriaSearchInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelCriteriaSearchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["criteria"] = arg1
	var arg2 *domainHotelCommon.Settings
	if tmp, ok := rawArgs["settings"]; ok {
		arg2, err = ec.unmarshalOHotelSettingsInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettings(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg2
	var arg3 *search.Filter
	if tmp, ok := rawArgs["filter"]; ok {
		arg3, err = ec.unmarshalOFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddOn_key(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOn",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOn_value(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOn",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNJSON2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOns_distribute(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribute, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOJSON2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOns_distribution(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddOn)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAddOn2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOn(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_transactions(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]common.Transactions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTransactions2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášTransactions(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_processTime(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessTime, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_count(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2áš–int(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_shared(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shared, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2áš–bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_hoursBefore(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoursBefore, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_penaltyType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.CancelPenaltyType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCancelPenaltyType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenaltyType(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPolicy_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPolicy_cancelPenalties(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPenalties, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.CancelPenalty)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCancelPenalty2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenalty(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_checkIn(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckIn, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_checkOut(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckOut, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_hotels(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2áš•string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]RoomCriteria)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoomCriteria2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRoomCriteria(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_language(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLanguage2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_currency(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCurrency2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_nationality(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nationality, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCountry2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_market(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Exchange_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Exchange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Exchange_rate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Exchange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_supplierCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_accessCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_market(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCodeSupplier(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelName(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_boardCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_boardCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCodeOriginal, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_paymentType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PaymentType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.PaymentType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPaymentType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPaymentType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_status(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.StatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatusType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášStatusType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Occupancy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOccupancy2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_rooms(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rooms, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Room)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoom2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoom(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_supplements(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplements, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Supplement)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSupplement2áš•áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplement(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_surcharges(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Surcharges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Surcharge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSurcharge2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSurcharge(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_rateRules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotelOptionSearch().RateRules(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]RateRulesType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_cancelPolicy(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPolicy, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.CancelPolicy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCancelPolicy2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_remarks(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remarks, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_addOns(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotelOptionSearch().AddOns(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddOns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAddOns2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOns(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_token(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptionID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_context(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_stats(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_HotelSearch_stats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatsRequest)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatsRequest2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatsRequest(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_auditData(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuditData, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*common.AuditData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAuditData2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAuditData(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_requestCriteria(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestCriteria, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CriteriaSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCriteriaSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášCriteriaSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_options(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Option)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelOptionSearch2áš•áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOption(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_errors(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOError2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_warnings(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOWarning2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelXQuery_search(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelXQuery",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelXQuery_searchStatusService(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelXQuery",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchStatusService, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNServiceStatus2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášServiceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_channel(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExchange2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášExchange(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_rules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Rule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRule2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRule(ctx, field.Selections, res)
}

func (ec *executionContext) _Occupancy_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Occupancy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Occupancy_paxes(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Occupancy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPax2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx, field.Selections, res)
}

func (ec *executionContext) _Pax_age(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Pax) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Pax",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExchange2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášExchange(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_markups(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Markups, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Markup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarkup2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkup(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_hotelX(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotelX(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelXQuery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelXQuery2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelXQuery(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_occupancyRefId(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OccupancyRefID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2áš–bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_units(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2áš–int(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_roomPrice(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomPrice, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.RoomPrice)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoomPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoomPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_beds(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beds, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Bed)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBed2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBed(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_ratePlans(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RatePlans, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.RatePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORatePlan2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRatePlan(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_promotions(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Promotions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Promotion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPromotion2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPromotion(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomCriteria_paxes(ctx context.Context, field graphql.CollectedField, obj *RoomCriteria) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomCriteria",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPax2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomPrice_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomPrice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomPrice_breakdown(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomPrice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Breakdown, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.PriceBreakDown)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPriceBreakdown2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPriceBreakDown(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.MarkupRuleType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMarkupRuleType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkupRuleType(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Search_hotel(ctx context.Context, field graphql.CollectedField, obj *Search) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Search",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Search_hotel_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_code(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_description(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_start(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_end(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_duration(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2áš–float64(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_name(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_total(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_staticConfiguration(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticConfiguration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStat2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_hotels(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_zones(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_cities(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_requestAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_responseAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_transactions(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatTransaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatTransaction2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_plugins(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatPlugin_name(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatPlugin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatPlugin_total(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatPlugin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_reference(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_total(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_buildRequest(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildRequest, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_workerCommunication(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkerCommunication, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_parseResponse(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParseResponse, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_total(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_validation(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_process(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Process, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_configuration(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_request(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_response(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_requestPlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestPlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_responsePlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponsePlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_hotels(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_zones(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_cities(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_dockerID(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DockerID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_Accesses(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accesses, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatAccess)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatAccess2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatAccess(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_supplementType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupplementType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.SupplementType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSupplementType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplementType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChargeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášChargeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_durationType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationType, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.DurationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODurationType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_quantity(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2áš–int(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_unit(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.UnitTimeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnitTimeType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_resort(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resort, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Resort)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOResort2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášResort(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPrice2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChargeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášChargeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_request(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_response(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2áš•string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2áš–string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccessFilterInput(ctx context.Context, v interface{}) (search.TypeFilter, error) {
	var it search.TypeFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalOID2áš–áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalOID2áš–áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBusinessRulesInput(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRules, error) {
	var it domainHotelCommon.BusinessRules
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "optionsQuota":
			var err error
			it.OptionsQuota, err = ec.unmarshalOInt2áš–int(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRulesType":
			var err error
			it.BusinessRulesType, err = ec.unmarshalOBusinessRulesType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConfigurationInput(ctx context.Context, v interface{}) (access.AccessConfiguration, error) {
	var it access.AccessConfiguration
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "username":
			var err error
			it.Username, err = ec.unmarshalOString2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "urls":
			var err error
			it.Urls, err = ec.unmarshalNUrlsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášUrls(ctx, v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			it.Parameters, err = ec.unmarshalOParameterInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx, v)
			if err != nil {
				return it, err
			}
		case "markets":
			var err error
			it.Markets, err = ec.unmarshalOString2áš–áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterInput(ctx context.Context, v interface{}) (search.Filter, error) {
	var it search.Filter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			it.Access, err = ec.unmarshalOAccessFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášRateRuleFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelCriteriaSearchInput(ctx context.Context, v interface{}) (HotelCriteriaSearchInput, error) {
	var it HotelCriteriaSearchInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "checkIn":
			var err error
			it.CheckIn, err = ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkOut":
			var err error
			it.CheckOut, err = ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hotels":
			var err error
			it.Hotels, err = ec.unmarshalOString2áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		case "destinations":
			var err error
			it.Destinations, err = ec.unmarshalOString2áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		case "occupancies":
			var err error
			it.Occupancies, err = ec.unmarshalNRoomInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx, v)
			if err != nil {
				return it, err
			}
		case "language":
			var err error
			it.Language, err = ec.unmarshalOLanguage2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOCurrency2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nationality":
			var err error
			it.Nationality, err = ec.unmarshalOCountry2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "market":
			var err error
			it.Market, err = ec.unmarshalOString2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelSettingsInput(ctx context.Context, v interface{}) (domainHotelCommon.Settings, error) {
	var it domainHotelCommon.Settings
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "context":
			var err error
			it.Context, err = ec.unmarshalOString2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "useContext":
			var err error
			it.UseContext, err = ec.unmarshalOBoolean2áš–bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "connectUser":
			var err error
			it.ConnectUser, err = ec.unmarshalOString2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "client":
			var err error
			it.Client, err = ec.unmarshalOID2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "group":
			var err error
			it.Group, err = ec.unmarshalOID2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "timeout":
			var err error
			it.Timeout, err = ec.unmarshalOInt2áš–int(ctx, v)
			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			it.AuditTransactions, err = ec.unmarshalOBoolean2áš–bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			it.BusinessRules, err = ec.unmarshalOBusinessRulesInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRules(ctx, v)
			if err != nil {
				return it, err
			}
		case "suppliers":
			var err error
			it.Suppliers, err = ec.unmarshalOHotelXSupplierInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx, v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			it.Plugins, err = ec.unmarshalOPluginStepInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx, v)
			if err != nil {
				return it, err
			}
		case "testMode":
			var err error
			it.TestMode, err = ec.unmarshalOBoolean2áš–bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientTokens":
			var err error
			it.ClientTokens, err = ec.unmarshalOString2áš–áš•string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXAccessInput(ctx context.Context, v interface{}) (domainHotelCommon.Access, error) {
	var it domainHotelCommon.Access
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessId":
			var err error
			it.AccessId, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "configuration":
			var err error
			it.Configuration, err = ec.unmarshalOConfigurationInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášAccessConfiguration(ctx, v)
			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOSettingsBaseInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettingsBase(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXFilterPluginTypeInput(ctx context.Context, v interface{}) (domainHotelCommon.FilterPlugin, error) {
	var it domainHotelCommon.FilterPlugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			it.Step, err = ec.unmarshalNPluginStepType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStepType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXFilterSearchInput(ctx context.Context, v interface{}) (search.FilterSearch, error) {
	var it search.FilterSearch
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			it.Access, err = ec.unmarshalOAccessFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášRateRuleFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "plugin":
			var err error
			it.Plugin, err = ec.unmarshalOHotelXPluginFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPluginType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXPluginFilterInput(ctx context.Context, v interface{}) (domainHotelCommon.FilterPluginType, error) {
	var it domainHotelCommon.FilterPluginType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalOHotelXFilterPluginTypeInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalOHotelXFilterPluginTypeInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXSupplierInput(ctx context.Context, v interface{}) (domainHotelCommon.Supplier, error) {
	var it domainHotelCommon.Supplier
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOSettingsBaseInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettingsBase(ctx, v)
			if err != nil {
				return it, err
			}
		case "code":
			var err error
			it.Code, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accesses":
			var err error
			it.Accesses, err = ec.unmarshalOHotelXAccessInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, v interface{}) (access.Parameter, error) {
	var it access.Parameter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaxInput(ctx context.Context, v interface{}) (domainHotelCommon.Pax, error) {
	var it domainHotelCommon.Pax
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "age":
			var err error
			it.Age, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPluginStepInput(ctx context.Context, v interface{}) (domainHotelCommon.PluginStep, error) {
	var it domainHotelCommon.PluginStep
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			it.Step, err = ec.unmarshalNPluginStepType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStepType(ctx, v)
			if err != nil {
				return it, err
			}
		case "pluginsType":
			var err error
			it.PluginsType, err = ec.unmarshalOPluginsInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPluginsInput(ctx context.Context, v interface{}) (domainHotelCommon.Plugin, error) {
	var it domainHotelCommon.Plugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPluginType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášPluginType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			it.Parameters, err = ec.unmarshalOParameterInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateRulesFilterInput(ctx context.Context, v interface{}) (search.RateRuleFilter, error) {
	var it search.RateRuleFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRoomInput(ctx context.Context, v interface{}) (domainHotelCommon.Occupancy, error) {
	var it domainHotelCommon.Occupancy
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "paxes":
			var err error
			it.Paxes, err = ec.unmarshalNPaxInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSettingsBaseInput(ctx context.Context, v interface{}) (domainHotelCommon.SettingsBase, error) {
	var it domainHotelCommon.SettingsBase
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "timeout":
			var err error
			it.Timeout, err = ec.unmarshalOInt2áš–int(ctx, v)
			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			it.AuditTransactions, err = ec.unmarshalOBoolean2áš–bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			it.BusinessRules, err = ec.unmarshalOBusinessRulesInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRules(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOCurrency2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUrlsInput(ctx context.Context, v interface{}) (access.Urls, error) {
	var it access.Urls
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "search":
			var err error
			it.Search, err = ec.unmarshalOURI2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "quote":
			var err error
			it.Quote, err = ec.unmarshalOURI2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "book":
			var err error
			it.Book, err = ec.unmarshalOURI2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		case "generic":
			var err error
			it.Generic, err = ec.unmarshalOURI2áš–string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _BookableOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *BookableOptionSearch) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case *domainHotelCommon.Option:
		return ec._HotelOptionSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Priceable(ctx context.Context, sel ast.SelectionSet, obj *Priceable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, &obj)
	case *domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, obj)
	case domainHotelCommon.Price:
		return ec._Price(ctx, sel, &obj)
	case *domainHotelCommon.Price:
		return ec._Price(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *Response) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case HotelSearch:
		return ec._HotelSearch(ctx, sel, &obj)
	case *HotelSearch:
		return ec._HotelSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addOnImplementors = []string{"AddOn"}

func (ec *executionContext) _AddOn(ctx context.Context, sel ast.SelectionSet, obj *AddOn) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOn")
		case "key":
			out.Values[i] = ec._AddOn_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._AddOn_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var addOnsImplementors = []string{"AddOns"}

func (ec *executionContext) _AddOns(ctx context.Context, sel ast.SelectionSet, obj *AddOns) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnsImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOns")
		case "distribute":
			out.Values[i] = ec._AddOns_distribute(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._AddOns_distribution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var auditDataImplementors = []string{"AuditData"}

func (ec *executionContext) _AuditData(ctx context.Context, sel ast.SelectionSet, obj *common.AuditData) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, auditDataImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditData")
		case "transactions":
			out.Values[i] = ec._AuditData_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._AuditData_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "processTime":
			out.Values[i] = ec._AuditData_processTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var bedImplementors = []string{"Bed"}

func (ec *executionContext) _Bed(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Bed) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bedImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bed")
		case "type":
			out.Values[i] = ec._Bed_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Bed_description(ctx, field, obj)
		case "count":
			out.Values[i] = ec._Bed_count(ctx, field, obj)
		case "shared":
			out.Values[i] = ec._Bed_shared(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var cancelPenaltyImplementors = []string{"CancelPenalty"}

func (ec *executionContext) _CancelPenalty(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPenaltyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPenalty")
		case "hoursBefore":
			out.Values[i] = ec._CancelPenalty_hoursBefore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "penaltyType":
			out.Values[i] = ec._CancelPenalty_penaltyType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "currency":
			out.Values[i] = ec._CancelPenalty_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._CancelPenalty_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var cancelPolicyImplementors = []string{"CancelPolicy"}

func (ec *executionContext) _CancelPolicy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPolicy")
		case "refundable":
			out.Values[i] = ec._CancelPolicy_refundable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cancelPenalties":
			out.Values[i] = ec._CancelPolicy_cancelPenalties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var criteriaSearchImplementors = []string{"CriteriaSearch"}

func (ec *executionContext) _CriteriaSearch(ctx context.Context, sel ast.SelectionSet, obj *CriteriaSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, criteriaSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CriteriaSearch")
		case "checkIn":
			out.Values[i] = ec._CriteriaSearch_checkIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "checkOut":
			out.Values[i] = ec._CriteriaSearch_checkOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotels":
			out.Values[i] = ec._CriteriaSearch_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._CriteriaSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "language":
			out.Values[i] = ec._CriteriaSearch_language(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CriteriaSearch_currency(ctx, field, obj)
		case "nationality":
			out.Values[i] = ec._CriteriaSearch_nationality(ctx, field, obj)
		case "market":
			out.Values[i] = ec._CriteriaSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var errorImplementors = []string{"Error"}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, errorImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "code":
			out.Values[i] = ec._Error_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Error_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Error_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var exchangeImplementors = []string{"Exchange"}

func (ec *executionContext) _Exchange(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, exchangeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Exchange")
		case "currency":
			out.Values[i] = ec._Exchange_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rate":
			out.Values[i] = ec._Exchange_rate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelOptionSearchImplementors = []string{"HotelOptionSearch", "BookableOptionSearch"}

func (ec *executionContext) _HotelOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Option) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelOptionSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelOptionSearch")
		case "supplierCode":
			out.Values[i] = ec._HotelOptionSearch_supplierCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "accessCode":
			out.Values[i] = ec._HotelOptionSearch_accessCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "market":
			out.Values[i] = ec._HotelOptionSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCode":
			out.Values[i] = ec._HotelOptionSearch_hotelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_hotelCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelName":
			out.Values[i] = ec._HotelOptionSearch_hotelName(ctx, field, obj)
		case "boardCode":
			out.Values[i] = ec._HotelOptionSearch_boardCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "boardCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_boardCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paymentType":
			out.Values[i] = ec._HotelOptionSearch_paymentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._HotelOptionSearch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._HotelOptionSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rooms":
			out.Values[i] = ec._HotelOptionSearch_rooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._HotelOptionSearch_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "supplements":
			out.Values[i] = ec._HotelOptionSearch_supplements(ctx, field, obj)
		case "surcharges":
			out.Values[i] = ec._HotelOptionSearch_surcharges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rateRules":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotelOptionSearch_rateRules(ctx, field, obj)
				return res
			})
		case "cancelPolicy":
			out.Values[i] = ec._HotelOptionSearch_cancelPolicy(ctx, field, obj)
		case "remarks":
			out.Values[i] = ec._HotelOptionSearch_remarks(ctx, field, obj)
		case "addOns":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotelOptionSearch_addOns(ctx, field, obj)
				return res
			})
		case "token":
			out.Values[i] = ec._HotelOptionSearch_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._HotelOptionSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelSearchImplementors = []string{"HotelSearch", "Response"}

func (ec *executionContext) _HotelSearch(ctx context.Context, sel ast.SelectionSet, obj *HotelSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelSearch")
		case "context":
			out.Values[i] = ec._HotelSearch_context(ctx, field, obj)
		case "stats":
			out.Values[i] = ec._HotelSearch_stats(ctx, field, obj)
		case "auditData":
			out.Values[i] = ec._HotelSearch_auditData(ctx, field, obj)
		case "requestCriteria":
			out.Values[i] = ec._HotelSearch_requestCriteria(ctx, field, obj)
		case "options":
			out.Values[i] = ec._HotelSearch_options(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._HotelSearch_errors(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._HotelSearch_warnings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelXQueryImplementors = []string{"HotelXQuery"}

func (ec *executionContext) _HotelXQuery(ctx context.Context, sel ast.SelectionSet, obj *HotelXQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelXQueryImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelXQuery")
		case "search":
			out.Values[i] = ec._HotelXQuery_search(ctx, field, obj)
		case "searchStatusService":
			out.Values[i] = ec._HotelXQuery_searchStatusService(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var markupImplementors = []string{"Markup", "Priceable"}

func (ec *executionContext) _Markup(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Markup) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, markupImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Markup")
		case "channel":
			out.Values[i] = ec._Markup_channel(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._Markup_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Markup_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Markup_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Markup_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Markup_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rules":
			out.Values[i] = ec._Markup_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var occupancyImplementors = []string{"Occupancy"}

func (ec *executionContext) _Occupancy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, occupancyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Occupancy")
		case "id":
			out.Values[i] = ec._Occupancy_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paxes":
			out.Values[i] = ec._Occupancy_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var paxImplementors = []string{"Pax"}

func (ec *executionContext) _Pax(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Pax) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, paxImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pax")
		case "age":
			out.Values[i] = ec._Pax_age(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var priceImplementors = []string{"Price", "Priceable"}

func (ec *executionContext) _Price(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Price) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Price")
		case "currency":
			out.Values[i] = ec._Price_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Price_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Price_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Price_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Price_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "markups":
			out.Values[i] = ec._Price_markups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var priceBreakdownImplementors = []string{"PriceBreakdown"}

func (ec *executionContext) _PriceBreakdown(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceBreakdownImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PriceBreakdown")
		case "effectiveDate":
			out.Values[i] = ec._PriceBreakdown_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expireDate":
			out.Values[i] = ec._PriceBreakdown_expireDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._PriceBreakdown_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var promotionImplementors = []string{"Promotion"}

func (ec *executionContext) _Promotion(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, promotionImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Promotion")
		case "code":
			out.Values[i] = ec._Promotion_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Promotion_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Promotion_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Promotion_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "hotelX":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotelX(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var ratePlanImplementors = []string{"RatePlan"}

func (ec *executionContext) _RatePlan(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ratePlanImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RatePlan")
		case "code":
			out.Values[i] = ec._RatePlan_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._RatePlan_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._RatePlan_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._RatePlan_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var resortImplementors = []string{"Resort"}

func (ec *executionContext) _Resort(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Resort) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resortImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resort")
		case "code":
			out.Values[i] = ec._Resort_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Resort_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Resort_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomImplementors = []string{"Room"}

func (ec *executionContext) _Room(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Room) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Room")
		case "occupancyRefId":
			out.Values[i] = ec._Room_occupancyRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "code":
			out.Values[i] = ec._Room_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Room_description(ctx, field, obj)
		case "refundable":
			out.Values[i] = ec._Room_refundable(ctx, field, obj)
		case "units":
			out.Values[i] = ec._Room_units(ctx, field, obj)
		case "roomPrice":
			out.Values[i] = ec._Room_roomPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "beds":
			out.Values[i] = ec._Room_beds(ctx, field, obj)
		case "ratePlans":
			out.Values[i] = ec._Room_ratePlans(ctx, field, obj)
		case "promotions":
			out.Values[i] = ec._Room_promotions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomCriteriaImplementors = []string{"RoomCriteria"}

func (ec *executionContext) _RoomCriteria(ctx context.Context, sel ast.SelectionSet, obj *RoomCriteria) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomCriteriaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomCriteria")
		case "paxes":
			out.Values[i] = ec._RoomCriteria_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomPriceImplementors = []string{"RoomPrice"}

func (ec *executionContext) _RoomPrice(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomPriceImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomPrice")
		case "price":
			out.Values[i] = ec._RoomPrice_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "breakdown":
			out.Values[i] = ec._RoomPrice_breakdown(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var ruleImplementors = []string{"Rule"}

func (ec *executionContext) _Rule(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Rule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ruleImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Rule")
		case "id":
			out.Values[i] = ec._Rule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Rule_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Rule_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Rule_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var searchImplementors = []string{"Search"}

func (ec *executionContext) _Search(ctx context.Context, sel ast.SelectionSet, obj *Search) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, searchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Search")
		case "hotel":
			out.Values[i] = ec._Search_hotel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var serviceStatusImplementors = []string{"ServiceStatus"}

func (ec *executionContext) _ServiceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceStatus")
		case "code":
			out.Values[i] = ec._ServiceStatus_code(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ServiceStatus_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ServiceStatus_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statImplementors = []string{"Stat"}

func (ec *executionContext) _Stat(ctx context.Context, sel ast.SelectionSet, obj *Stat) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stat")
		case "start":
			out.Values[i] = ec._Stat_start(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "end":
			out.Values[i] = ec._Stat_end(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "duration":
			out.Values[i] = ec._Stat_duration(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statAccessImplementors = []string{"StatAccess"}

func (ec *executionContext) _StatAccess(ctx context.Context, sel ast.SelectionSet, obj *StatAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statAccessImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatAccess")
		case "name":
			out.Values[i] = ec._StatAccess_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatAccess_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "staticConfiguration":
			out.Values[i] = ec._StatAccess_staticConfiguration(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatAccess_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatAccess_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatAccess_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestAccess":
			out.Values[i] = ec._StatAccess_requestAccess(ctx, field, obj)
		case "responseAccess":
			out.Values[i] = ec._StatAccess_responseAccess(ctx, field, obj)
		case "transactions":
			out.Values[i] = ec._StatAccess_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._StatAccess_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statPluginImplementors = []string{"StatPlugin"}

func (ec *executionContext) _StatPlugin(ctx context.Context, sel ast.SelectionSet, obj *StatPlugin) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statPluginImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatPlugin")
		case "name":
			out.Values[i] = ec._StatPlugin_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatPlugin_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statTransactionImplementors = []string{"StatTransaction"}

func (ec *executionContext) _StatTransaction(ctx context.Context, sel ast.SelectionSet, obj *StatTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatTransaction")
		case "reference":
			out.Values[i] = ec._StatTransaction_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatTransaction_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "buildRequest":
			out.Values[i] = ec._StatTransaction_buildRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "workerCommunication":
			out.Values[i] = ec._StatTransaction_workerCommunication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parseResponse":
			out.Values[i] = ec._StatTransaction_parseResponse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statsRequestImplementors = []string{"StatsRequest"}

func (ec *executionContext) _StatsRequest(ctx context.Context, sel ast.SelectionSet, obj *StatsRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statsRequestImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatsRequest")
		case "total":
			out.Values[i] = ec._StatsRequest_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "validation":
			out.Values[i] = ec._StatsRequest_validation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "process":
			out.Values[i] = ec._StatsRequest_process(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configuration":
			out.Values[i] = ec._StatsRequest_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "request":
			out.Values[i] = ec._StatsRequest_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._StatsRequest_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestPlugin":
			out.Values[i] = ec._StatsRequest_requestPlugin(ctx, field, obj)
		case "responsePlugin":
			out.Values[i] = ec._StatsRequest_responsePlugin(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatsRequest_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatsRequest_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatsRequest_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dockerID":
			out.Values[i] = ec._StatsRequest_dockerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "Accesses":
			out.Values[i] = ec._StatsRequest_Accesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var supplementImplementors = []string{"Supplement"}

func (ec *executionContext) _Supplement(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, supplementImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Supplement")
		case "code":
			out.Values[i] = ec._Supplement_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Supplement_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Supplement_description(ctx, field, obj)
		case "supplementType":
			out.Values[i] = ec._Supplement_supplementType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "chargeType":
			out.Values[i] = ec._Supplement_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Supplement_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "durationType":
			out.Values[i] = ec._Supplement_durationType(ctx, field, obj)
		case "quantity":
			out.Values[i] = ec._Supplement_quantity(ctx, field, obj)
		case "unit":
			out.Values[i] = ec._Supplement_unit(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Supplement_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Supplement_expireDate(ctx, field, obj)
		case "resort":
			out.Values[i] = ec._Supplement_resort(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Supplement_price(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var surchargeImplementors = []string{"Surcharge"}

func (ec *executionContext) _Surcharge(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, surchargeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Surcharge")
		case "chargeType":
			out.Values[i] = ec._Surcharge_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Surcharge_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._Surcharge_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Surcharge_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var transactionsImplementors = []string{"Transactions"}

func (ec *executionContext) _Transactions(ctx context.Context, sel ast.SelectionSet, obj *common.Transactions) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transactionsImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transactions")
		case "request":
			out.Values[i] = ec._Transactions_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._Transactions_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._Transactions_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var warningImplementors = []string{"Warning"}

func (ec *executionContext) _Warning(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, warningImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Warning")
		case "code":
			out.Values[i] = ec._Warning_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Warning_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Warning_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAddOn2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOn(ctx context.Context, sel ast.SelectionSet, v AddOn) graphql.Marshaler {
	return ec._AddOn(ctx, sel, &v)
}

func (ec *executionContext) marshalNBed2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBed(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Bed) graphql.Marshaler {
	return ec._Bed(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) marshalNCancelPenalty2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenalty(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPenalty) graphql.Marshaler {
	return ec._CancelPenalty(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCancelPenaltyType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenaltyType(ctx context.Context, v interface{}) (domainHotelCommon.CancelPenaltyType, error) {
	var res domainHotelCommon.CancelPenaltyType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNCancelPenaltyType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenaltyType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPenaltyType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChargeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášChargeType(ctx context.Context, v interface{}) (domainHotelCommon.ChargeType, error) {
	var res domainHotelCommon.ChargeType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNChargeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášChargeType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.ChargeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCurrency2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNCurrency2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalNError2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx context.Context, sel ast.SelectionSet, v common.AdviseMessage) graphql.Marshaler {
	return ec._Error(ctx, sel, &v)
}

func (ec *executionContext) marshalNExchange2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášExchange(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Exchange) graphql.Marshaler {
	return ec._Exchange(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalNHotelXAccessInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx context.Context, v interface{}) (domainHotelCommon.Access, error) {
	return ec.unmarshalInputHotelXAccessInput(ctx, v)
}

func (ec *executionContext) unmarshalNHotelXFilterPluginTypeInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx context.Context, v interface{}) (domainHotelCommon.FilterPlugin, error) {
	return ec.unmarshalInputHotelXFilterPluginTypeInput(ctx, v)
}

func (ec *executionContext) unmarshalNHotelXSupplierInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx context.Context, v interface{}) (domainHotelCommon.Supplier, error) {
	return ec.unmarshalInputHotelXSupplierInput(ctx, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalNJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalNMarkup2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkup(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Markup) graphql.Marshaler {
	return ec._Markup(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMarkupRuleType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkupRuleType(ctx context.Context, v interface{}) (domainHotelCommon.MarkupRuleType, error) {
	var res domainHotelCommon.MarkupRuleType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMarkupRuleType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkupRuleType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.MarkupRuleType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOccupancy2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Occupancy) graphql.Marshaler {
	return ec._Occupancy(ctx, sel, &v)
}

func (ec *executionContext) marshalNOccupancy2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Occupancy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOccupancy2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNParameterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx context.Context, v interface{}) (access.Parameter, error) {
	return ec.unmarshalInputParameterInput(ctx, v)
}

func (ec *executionContext) marshalNPax2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Pax) graphql.Marshaler {
	return ec._Pax(ctx, sel, &v)
}

func (ec *executionContext) marshalNPax2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Pax) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPax2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPaxInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx context.Context, v interface{}) (domainHotelCommon.Pax, error) {
	return ec.unmarshalInputPaxInput(ctx, v)
}

func (ec *executionContext) unmarshalNPaxInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx context.Context, v interface{}) ([]domainHotelCommon.Pax, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Pax, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPaxInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPax(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPaymentType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPaymentType(ctx context.Context, v interface{}) (domainHotelCommon.PaymentType, error) {
	var res domainHotelCommon.PaymentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPaymentType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPaymentType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PaymentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginStepInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx context.Context, v interface{}) (domainHotelCommon.PluginStep, error) {
	return ec.unmarshalInputPluginStepInput(ctx, v)
}

func (ec *executionContext) unmarshalNPluginStepType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStepType(ctx context.Context, v interface{}) (domainHotelCommon.PluginStepType, error) {
	var res domainHotelCommon.PluginStepType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPluginStepType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStepType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PluginStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášPluginType(ctx context.Context, v interface{}) (PluginType, error) {
	var res PluginType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPluginType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášPluginType(ctx context.Context, sel ast.SelectionSet, v PluginType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx context.Context, v interface{}) (domainHotelCommon.Plugin, error) {
	return ec.unmarshalInputPluginsInput(ctx, v)
}

func (ec *executionContext) marshalNPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Price) graphql.Marshaler {
	return ec._Price(ctx, sel, &v)
}

func (ec *executionContext) marshalNPriceBreakdown2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPriceBreakDown(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	return ec._PriceBreakdown(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromotion2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPromotion(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Promotion) graphql.Marshaler {
	return ec._Promotion(ctx, sel, &v)
}

func (ec *executionContext) marshalNRatePlan2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRatePlan(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.RatePlan) graphql.Marshaler {
	return ec._RatePlan(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRateRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx context.Context, v interface{}) (RateRulesType, error) {
	var res RateRulesType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNRateRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx context.Context, sel ast.SelectionSet, v RateRulesType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRoom2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoom(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Room) graphql.Marshaler {
	return ec._Room(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoom2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoom(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Room) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoom2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRoomCriteria2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRoomCriteria(ctx context.Context, sel ast.SelectionSet, v RoomCriteria) graphql.Marshaler {
	return ec._RoomCriteria(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoomCriteria2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRoomCriteria(ctx context.Context, sel ast.SelectionSet, v []RoomCriteria) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomCriteria2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRoomCriteria(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNRoomInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx context.Context, v interface{}) (domainHotelCommon.Occupancy, error) {
	return ec.unmarshalInputRoomInput(ctx, v)
}

func (ec *executionContext) unmarshalNRoomInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx context.Context, v interface{}) ([]domainHotelCommon.Occupancy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Occupancy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNRoomInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOccupancy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRoomPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRoomPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.RoomPrice) graphql.Marshaler {
	return ec._RoomPrice(ctx, sel, &v)
}

func (ec *executionContext) marshalNRule2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRule(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Rule) graphql.Marshaler {
	return ec._Rule(ctx, sel, &v)
}

func (ec *executionContext) marshalNRule2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRule(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Rule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRule2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNServiceStatus2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášServiceStatus(ctx context.Context, sel ast.SelectionSet, v ServiceStatus) graphql.Marshaler {
	return ec._ServiceStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx context.Context, sel ast.SelectionSet, v Stat) graphql.Marshaler {
	return ec._Stat(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatAccess2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatAccess(ctx context.Context, sel ast.SelectionSet, v StatAccess) graphql.Marshaler {
	return ec._StatAccess(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatAccess2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatAccess(ctx context.Context, sel ast.SelectionSet, v []StatAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatAccess2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNStatPlugin2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx context.Context, sel ast.SelectionSet, v StatPlugin) graphql.Marshaler {
	return ec._StatPlugin(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatTransaction2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatTransaction(ctx context.Context, sel ast.SelectionSet, v StatTransaction) graphql.Marshaler {
	return ec._StatTransaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatTransaction2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatTransaction(ctx context.Context, sel ast.SelectionSet, v []StatTransaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatTransaction2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNStatusType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášStatusType(ctx context.Context, v interface{}) (domainHotelCommon.StatusType, error) {
	var res domainHotelCommon.StatusType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNStatusType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášStatusType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.StatusType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNString2áš•string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2áš•string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNString2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.marshalNString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalNSupplementType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplementType(ctx context.Context, v interface{}) (domainHotelCommon.SupplementType, error) {
	var res domainHotelCommon.SupplementType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSupplementType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplementType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.SupplementType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSurcharge2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSurcharge(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Surcharge) graphql.Marshaler {
	return ec._Surcharge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSurcharge2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSurcharge(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Surcharge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSurcharge2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSurcharge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTransactions2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášTransactions(ctx context.Context, sel ast.SelectionSet, v common.Transactions) graphql.Marshaler {
	return ec._Transactions(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactions2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášTransactions(ctx context.Context, sel ast.SelectionSet, v []common.Transactions) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactions2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášTransactions(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNUrlsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášUrls(ctx context.Context, v interface{}) (access.Urls, error) {
	return ec.unmarshalInputUrlsInput(ctx, v)
}

func (ec *executionContext) marshalNWarning2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx context.Context, sel ast.SelectionSet, v common.AdviseMessage) graphql.Marshaler {
	return ec._Warning(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalN__DirectiveLocation2áš•string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2áš•string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOAccessFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášTypeFilter(ctx context.Context, v interface{}) (search.TypeFilter, error) {
	return ec.unmarshalInputAccessFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOAccessFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášTypeFilter(ctx context.Context, v interface{}) (*search.TypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášTypeFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAddOn2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOn(ctx context.Context, sel ast.SelectionSet, v []AddOn) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAddOn2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAddOns2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOns(ctx context.Context, sel ast.SelectionSet, v AddOns) graphql.Marshaler {
	return ec._AddOns(ctx, sel, &v)
}

func (ec *executionContext) marshalOAddOns2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášAddOns(ctx context.Context, sel ast.SelectionSet, v *AddOns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddOns(ctx, sel, v)
}

func (ec *executionContext) marshalOAuditData2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAuditData(ctx context.Context, sel ast.SelectionSet, v common.AuditData) graphql.Marshaler {
	return ec._AuditData(ctx, sel, &v)
}

func (ec *executionContext) marshalOAuditData2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAuditData(ctx context.Context, sel ast.SelectionSet, v *common.AuditData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuditData(ctx, sel, v)
}

func (ec *executionContext) marshalOBed2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBed(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Bed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBed2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2áš–bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2áš–bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOBusinessRulesInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRules(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRules, error) {
	return ec.unmarshalInputBusinessRulesInput(ctx, v)
}

func (ec *executionContext) unmarshalOBusinessRulesInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRules(ctx context.Context, v interface{}) (*domainHotelCommon.BusinessRules, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBusinessRulesInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRules(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBusinessRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRulesType, error) {
	var res domainHotelCommon.BusinessRulesType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBusinessRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.BusinessRulesType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBusinessRulesType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx context.Context, v interface{}) (*domainHotelCommon.BusinessRulesType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBusinessRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBusinessRulesType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášBusinessRulesType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.BusinessRulesType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOCancelPenalty2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenalty(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.CancelPenalty) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCancelPenalty2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPenalty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCancelPolicy2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPolicy(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPolicy) graphql.Marshaler {
	return ec._CancelPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalOCancelPolicy2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášCancelPolicy(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CancelPolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalOConfigurationInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášAccessConfiguration(ctx context.Context, v interface{}) (access.AccessConfiguration, error) {
	return ec.unmarshalInputConfigurationInput(ctx, v)
}

func (ec *executionContext) unmarshalOConfigurationInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášAccessConfiguration(ctx context.Context, v interface{}) (*access.AccessConfiguration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOConfigurationInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášAccessConfiguration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCountry2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOCountry2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOCountry2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCountry2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCountry2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCountry2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOCriteriaSearch2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášCriteriaSearch(ctx context.Context, sel ast.SelectionSet, v CriteriaSearch) graphql.Marshaler {
	return ec._CriteriaSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOCriteriaSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášCriteriaSearch(ctx context.Context, sel ast.SelectionSet, v *CriteriaSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CriteriaSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCurrency2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOCurrency2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOCurrency2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCurrency2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCurrency2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCurrency2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODate2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODate2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODate2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODate2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalODurationType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx context.Context, v interface{}) (domainHotelCommon.DurationType, error) {
	var res domainHotelCommon.DurationType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODurationType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.DurationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODurationType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx context.Context, v interface{}) (*domainHotelCommon.DurationType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODurationType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODurationType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášDurationType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.DurationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOError2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx context.Context, sel ast.SelectionSet, v []common.AdviseMessage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNError2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášFilter(ctx context.Context, v interface{}) (search.Filter, error) {
	return ec.unmarshalInputFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášFilter(ctx context.Context, v interface{}) (*search.Filter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2áš–float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2áš–float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOHotelCriteriaSearchInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelCriteriaSearchInput(ctx context.Context, v interface{}) (HotelCriteriaSearchInput, error) {
	return ec.unmarshalInputHotelCriteriaSearchInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelCriteriaSearchInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelCriteriaSearchInput(ctx context.Context, v interface{}) (*HotelCriteriaSearchInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelCriteriaSearchInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelCriteriaSearchInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOHotelOptionSearch2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOption(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Option) graphql.Marshaler {
	return ec._HotelOptionSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelOptionSearch2áš•áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOption(ctx context.Context, sel ast.SelectionSet, v []*domainHotelCommon.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHotelOptionSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOHotelOptionSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášOption(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelOptionSearch(ctx, sel, v)
}

func (ec *executionContext) marshalOHotelSearch2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelSearch(ctx context.Context, sel ast.SelectionSet, v HotelSearch) graphql.Marshaler {
	return ec._HotelSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelSearch2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelSearch(ctx context.Context, sel ast.SelectionSet, v *HotelSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHotelSettingsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettings(ctx context.Context, v interface{}) (domainHotelCommon.Settings, error) {
	return ec.unmarshalInputHotelSettingsInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelSettingsInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettings(ctx context.Context, v interface{}) (*domainHotelCommon.Settings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelSettingsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettings(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXAccessInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx context.Context, v interface{}) ([]domainHotelCommon.Access, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Access, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXAccessInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXAccessInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx context.Context, v interface{}) (*[]domainHotelCommon.Access, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXAccessInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášAccess(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXFilterPluginTypeInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx context.Context, v interface{}) ([]domainHotelCommon.FilterPlugin, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.FilterPlugin, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXFilterPluginTypeInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXFilterPluginTypeInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx context.Context, v interface{}) (*[]domainHotelCommon.FilterPlugin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXFilterPluginTypeInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPlugin(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXPluginFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPluginType(ctx context.Context, v interface{}) (domainHotelCommon.FilterPluginType, error) {
	return ec.unmarshalInputHotelXPluginFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelXPluginFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPluginType(ctx context.Context, v interface{}) (*domainHotelCommon.FilterPluginType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXPluginFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášFilterPluginType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOHotelXQuery2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelXQuery(ctx context.Context, sel ast.SelectionSet, v HotelXQuery) graphql.Marshaler {
	return ec._HotelXQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelXQuery2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášHotelXQuery(ctx context.Context, sel ast.SelectionSet, v *HotelXQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelXQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHotelXSupplierInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx context.Context, v interface{}) ([]domainHotelCommon.Supplier, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Supplier, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXSupplierInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXSupplierInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx context.Context, v interface{}) (*[]domainHotelCommon.Supplier, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXSupplierInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplier(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2áš•string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2áš•string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOID2áš–áš•string(ctx context.Context, v interface{}) (*[]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2áš•string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2áš–áš•string(ctx context.Context, sel ast.SelectionSet, v *[]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2áš•string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2áš–int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2áš–int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOJSON2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOJSON2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOJSON2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOJSON2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOLanguage2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOLanguage2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOLanguage2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLanguage2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOLanguage2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOLanguage2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOMarkup2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkup(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Markup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarkup2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášMarkup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOParameterInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx context.Context, v interface{}) ([]access.Parameter, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]access.Parameter, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNParameterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOParameterInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx context.Context, v interface{}) (*[]access.Parameter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOParameterInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹accessášParameter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPluginStepInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx context.Context, v interface{}) ([]domainHotelCommon.PluginStep, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.PluginStep, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPluginStepInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPluginStepInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx context.Context, v interface{}) (*[]domainHotelCommon.PluginStep, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPluginStepInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPluginStep(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPluginsInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx context.Context, v interface{}) ([]domainHotelCommon.Plugin, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Plugin, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPluginsInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPluginsInput2áš–áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx context.Context, v interface{}) (*[]domainHotelCommon.Plugin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPluginsInput2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPlugin(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPrice2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Price) graphql.Marshaler {
	return ec._Price(ctx, sel, &v)
}

func (ec *executionContext) marshalOPrice2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPrice(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Price) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Price(ctx, sel, v)
}

func (ec *executionContext) marshalOPriceBreakdown2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPriceBreakDown(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPriceBreakdown2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPriceBreakDown(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPromotion2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPromotion(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Promotion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPromotion2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášPromotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalORatePlan2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRatePlan(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.RatePlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRatePlan2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášRatePlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalORateRulesFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášRateRuleFilter(ctx context.Context, v interface{}) (search.RateRuleFilter, error) {
	return ec.unmarshalInputRateRulesFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalORateRulesFilterInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášRateRuleFilter(ctx context.Context, v interface{}) (*search.RateRuleFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalORateRulesFilterInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹searchášRateRuleFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx context.Context, v interface{}) ([]RateRulesType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]RateRulesType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNRateRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORateRulesType2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx context.Context, sel ast.SelectionSet, v []RateRulesType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRateRulesType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášRateRulesType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOResort2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášResort(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Resort) graphql.Marshaler {
	return ec._Resort(ctx, sel, &v)
}

func (ec *executionContext) marshalOResort2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášResort(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Resort) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resort(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSettingsBaseInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettingsBase(ctx context.Context, v interface{}) (domainHotelCommon.SettingsBase, error) {
	return ec.unmarshalInputSettingsBaseInput(ctx, v)
}

func (ec *executionContext) unmarshalOSettingsBaseInput2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettingsBase(ctx context.Context, v interface{}) (*domainHotelCommon.SettingsBase, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSettingsBaseInput2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSettingsBase(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOStat2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx context.Context, sel ast.SelectionSet, v Stat) graphql.Marshaler {
	return ec._Stat(ctx, sel, &v)
}

func (ec *executionContext) marshalOStat2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStat(ctx context.Context, sel ast.SelectionSet, v *Stat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Stat(ctx, sel, v)
}

func (ec *executionContext) marshalOStatPlugin2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx context.Context, sel ast.SelectionSet, v StatPlugin) graphql.Marshaler {
	return ec._StatPlugin(ctx, sel, &v)
}

func (ec *executionContext) marshalOStatPlugin2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx context.Context, sel ast.SelectionSet, v []StatPlugin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatPlugin2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOStatPlugin2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatPlugin(ctx context.Context, sel ast.SelectionSet, v *StatPlugin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatPlugin(ctx, sel, v)
}

func (ec *executionContext) marshalOStatsRequest2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatsRequest(ctx context.Context, sel ast.SelectionSet, v StatsRequest) graphql.Marshaler {
	return ec._StatsRequest(ctx, sel, &v)
}

func (ec *executionContext) marshalOStatsRequest2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹presenteráš‹gqlgensmášStatsRequest(ctx context.Context, sel ast.SelectionSet, v *StatsRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatsRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2áš•string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2áš•string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOString2áš–áš•string(ctx context.Context, v interface{}) (*[]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2áš•string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2áš–áš•string(ctx context.Context, sel ast.SelectionSet, v *[]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2áš•string(ctx, sel, *v)
}

func (ec *executionContext) marshalOSupplement2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplement(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Supplement) graphql.Marshaler {
	return ec._Supplement(ctx, sel, &v)
}

func (ec *executionContext) marshalOSupplement2áš•áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplement(ctx context.Context, sel ast.SelectionSet, v []*domainHotelCommon.Supplement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSupplement2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSupplement2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášSupplement(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Supplement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Supplement(ctx, sel, v)
}

func (ec *executionContext) unmarshalOURI2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOURI2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOURI2áš–string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOURI2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOURI2áš–string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOURI2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUnitTimeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx context.Context, v interface{}) (domainHotelCommon.UnitTimeType, error) {
	var res domainHotelCommon.UnitTimeType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOUnitTimeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.UnitTimeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOUnitTimeType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx context.Context, v interface{}) (*domainHotelCommon.UnitTimeType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUnitTimeType2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUnitTimeType2áš–githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹domainHotelCommonášUnitTimeType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.UnitTimeType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOWarning2áš•githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx context.Context, sel ast.SelectionSet, v []common.AdviseMessage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWarning2githubáš—comáš‹travelgateXáš‹presentersáš‘benchmarkáš‹pkgáš‹commonášAdviseMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__EnumValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2áš•githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2áš–githubáš—comáš‹99designsáš‹gqlgenáš‹graphqláš‹introspectionášType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
